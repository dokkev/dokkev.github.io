<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://dokkev.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://dokkev.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-02-12T04:42:25+00:00</updated><id>https://dokkev.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry xml:lang="ko"><title type="html">[로봇 하드웨어 06] - QDD 엑추에이터</title><link href="https://dokkev.github.io/hardware06-kr/" rel="alternate" type="text/html" title="[로봇 하드웨어 06] - QDD 엑추에이터"/><published>2025-12-06T00:00:00+00:00</published><updated>2025-12-06T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-06.kr</id><content type="html" xml:base="https://dokkev.github.io/hardware06-kr/"><![CDATA[<p>이전 포스트에서 다룬 고감속비 기반 시스템(Harmonic Drive 등)이 소형 모터와 고감속기를 조합하여 토크를 확보하는 방식이라면, <strong>QDD (Quasi-Direct Drive)</strong> 액추에이터는 상반된 설계 철학을 가집니다.</p> <p>QDD의 주요 설계 목표는 다음과 같습니다.</p> <ol> <li><strong>Low Mechanical Impedance:</strong> 모터 로터의 관성을 기계적으로 낮게 유지할 것.</li> <li><strong>High Transparency:</strong> 마찰, 백래시 등 기계적 비선형성을 최소화할 것.</li> <li><strong>High Bandwidth:</strong> 높은 응답성을 통해 고주파수의 힘과 운동 명령을 수행할 것.</li> </ol> <p>이러한 특성은 4족 보행 로봇이나 휴머노이드와 같이 외부 환경과의 동적 상호작용(Dynamic Interaction)이 잦은 시스템에 자주 쓰입니다.</p> <h2 id="구조-및-설계">구조 및 설계</h2> <p>QDD는 완전한 무감속(Direct Drive) 방식은 아니며, 통상 <strong>6:1 ~ 10:1</strong> 수준의 낮은 기어비를 사용합니다.</p> <p>낮은 기어비로 인한 토크 부족을 보완하기 위해 <strong>High Torque Density 모터</strong>를 사용합니다.</p> <ul> <li><strong>Motor:</strong> 공극 반경(Air gap radius)을 키워 토크를 확보하기 위해 직경이 크고 극수(Pole count)가 많은 <strong>BLDC Outrunner</strong> 모터를 주로 사용합니다.</li> <li><strong>Reducer:</strong> 주로 <strong>Planetary Gear</strong>나 <strong>Cycloidal Drive</strong>를 사용하며, 전체 부피를 줄이기 위해 감속기를 모터 스테이터 내부 공간에 배치하는 설계를 취합니다.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/pancake-480.webp 480w,/assets/img/hardware/pancake-800.webp 800w,/assets/img/hardware/pancake-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/pancake.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> QDD 액추에이터 예시 [1] </div> </div> </div> <figure> <iframe width="720" height="405" src="https://www.youtube.com/embed/Mhxz2Bj2RXA" title="MIT Mini Cheetah Actuator Teardown" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""> </iframe> <figcaption style="text-align: center;"> <em>MIT Mini Cheetah Actuator Teardown</em> </figcaption> </figure> <p>이러한 구조를 통해 모터와 감속기가 일체화된 컴팩트한 관절 모듈 구성이 가능합니다.</p> <h2 id="핵심-개념-힘-운동-투명성-force-motion-transparency">핵심 개념: 힘-운동 투명성 (Force-Motion Transparency)</h2> <p>QDD의 핵심 성능 지표는 <strong>Force-Motion Transparency</strong>입니다. 이는 본래 <strong>Teleoperation</strong> 분야의 개념으로, 입력단의 힘과 운동이 왜곡 없이 출력단으로 전달되고, 반대로 출력단의 반력(Reaction force)이 입력단으로 손실 없이 전달되는 정도를 의미합니다.</p> <p>기계적 임피던스 $Z(s)$ 모델에서 이를 해석하면, 시스템 내부의 관성($M$)과 마찰($B$)이 최소화되어야 함을 뜻합니다.</p> \[Z(s) = \frac{F(s)}{v(s)} = Ms + B + \frac{K}{s}\] <p>QDD는 감속비를 낮춤으로써 고주파 영역의 왜곡 요인인 <strong>관성($M$)</strong>과 저주파 영역의 왜곡 요인인 <strong>마찰($B$)</strong>을 동시에 저감하여, 전 주파수 대역에서 높은 <strong>Transparency</strong>를 확보하는 것을 목표로 합니다.</p> <h2 id="qdd를-정의하는-두-가지-관점">QDD를 정의하는 두 가지 관점</h2> <p>QDD를 구분하는 엄밀한 정량적 기준은 없으나, 학계와 업계에서는 주로 다음 두 가지 관점에서 정의합니다.</p> <h3 id="1-동적-투명성-관점-dynamic-transparency">1. 동적 투명성 관점 (Dynamic Transparency)</h3> <p>충격 완화와 고속 제어 성능에 초점을 맞춘 관점입니다. 핵심 인자는 <strong>Reflected Inertia(반사 관성)</strong>입니다.</p> <p>모터 로터의 관성($J_m$)은 감속기를 거치며 기어비의 제곱($N^2$)에 비례하여 증폭됩니다.</p> \[J_{ref} = J_m \times N^2\] <p>고감속비 시스템(예: 100:1)에서는 로터 관성이 10,000배로 증폭되어 관절이 동적으로 둔감해지는 반면, QDD(예: 6:1)는 관성 증폭이 36배 수준에 그칩니다.</p> <p><strong>낮은 Reflected Inertia의 이점:</strong></p> <ul> <li><strong>Impact Mitigation:</strong> 지면 접촉이나 충돌 시 발생하는 충격 에너지를 기계적으로 흡수하거나 흘려보낼 수 있습니다.</li> <li><strong>High Control Bandwidth:</strong> 시스템의 관성이 작아 빠른 가감속과 고주파수 제어 명령 추종이 가능합니다.</li> </ul> <h3 id="2-준정적-힘-투명성-관점-quasi-static-force-transparency">2. 준정적 힘 투명성 관점 (Quasi-static Force Transparency)</h3> <p>전류 기반의 힘 추정 정확도에 초점을 맞춘 관점입니다.</p> <p>감속비가 다소 높더라도(20:1 내외), 시스템의 마찰이나 히스테리시스와 같은 <strong>기계적 비선형성(Non-linearity)</strong>이 충분히 낮다면 QDD의 범주에 포함됩니다.</p> <ul> <li><strong>High Backdrivability:</strong> 전원이 차단된 상태에서도 외부 힘에 의해 출력축이 부드럽게 구동되어야 합니다.</li> <li><strong>Linearity:</strong> 마찰이 적어 전류($I$)와 토크($\tau$) 간의 관계가 선형성을 유지합니다.</li> </ul> <h2 id="proprioceptive-actuation">Proprioceptive Actuation</h2> <p>QDD 하드웨어의 특성을 활용한 제어 방식이 <strong>Proprioceptive Actuation</strong>입니다.</p> <p>이는 별도의 <strong>Torque Sensor</strong> 없이 모터의 <strong>전류(Current)</strong> 정보만을 이용하여 외력을 추정하고 제어하는 방식을 의미합니다.</p> <p>QDD 시스템에서는:</p> <ol> <li>기어 마찰과 비선형성이 낮고,</li> <li>Reflected Inertia가 작아 동적 외란의 영향이 적으므로,</li> <li><strong>“모터 전류 $\propto$ 외부 토크”</strong>의 관계가 성립합니다.</li> </ol> <p>이를 통해 복잡한 센서 구성 없이도 <strong>Force Sensing</strong>과 <strong>Force Control</strong>을 구현할 수 있습니다.</p> <blockquote> <p><strong>참고:</strong> 이 개념은 MIT Biomimetic Robotics Lab의 논문 <em>“Proprioceptive Actuator Design in the MIT Cheetah [2]”</em>에서 소개되었으며, 자세한 내용은 나중에 다루도록 하겠습니다.</p> </blockquote> <h2 id="학습-기반-제어와의-시너지-및-한계">학습 기반 제어와의 시너지 및 한계</h2> <h3 id="학습-기반-제어rl와의-적합성">학습 기반 제어(RL)와의 적합성</h3> <p>QDD는 최근의 <strong>강화학습(Reinforcement Learning, RL)</strong> 기반 제어 연구에 적합한 특성을 가집니다.</p> <ul> <li><strong>Sim-to-Real Gap 감소:</strong> 마찰, 백래시 등 시뮬레이션에서 모델링하기 어려운 비선형 요소가 적어, 시뮬레이션 상의 정책(Policy)을 실제 하드웨어에 적용했을 때의 성능 저하가 적습니다.</li> </ul> <h3 id="한계점-발열-thermal-issue">한계점: 발열 (Thermal Issue)</h3> <p>QDD의 주요 단점은 <strong>발열</strong>입니다. 낮은 기어비로 높은 토크를 생성해야 하므로 모터에 인가되는 전류량이 많습니다. 모터의 동손(Copper loss, $P_{loss} = I^2 R$)은 전류의 제곱에 비례하므로 발열량이 급격히 증가합니다.</p> <ul> <li><strong>Low Torque Constant:</strong> 기어비에 의한 토크 증폭 효과가 적어 모터 자체의 토크 상수에 의존해야 합니다.</li> <li><strong>Thermal Management:</strong> 높은 중력 부하를 지속적으로 지탱해야 하는 정적인 작업(Static holding)에서는 효율이 낮고 과열 위험이 있습니다.</li> </ul> <p>따라서 QDD 액추에이터는 정적인 고부하 작업보다는, 지속적으로 움직이며 에너지를 소비하고 회생하는 <strong>동적(Dynamic) 작업</strong>에 적합합니다. 실제 운용 시에는 모터의 열 모델링과 냉각 대책이 필수적으로 고려되어야 합니다.</p> <h3 id="references">References</h3> <p>[1] https://www.semanticscholar.org/paper/A-low-cost-modular-actuator-for-dynamic-robots-Katz/80732f8a46655aa4a1037a7fbdc154f4ceb33c50</p> <p>[2] https://fab.cba.mit.edu/classes/865.18/motion/papers/mit-cheetah-actuator.pdf</p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - QDD 액추에이터]]></summary></entry><entry xml:lang="ko"><title type="html">[로봇 하드웨어 05] - 사이클로이드 감속기</title><link href="https://dokkev.github.io/hardware05-kr/" rel="alternate" type="text/html" title="[로봇 하드웨어 05] - 사이클로이드 감속기"/><published>2025-12-05T00:00:00+00:00</published><updated>2025-12-05T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-05.kr</id><content type="html" xml:base="https://dokkev.github.io/hardware05-kr/"><![CDATA[<p>이번 포스트에서는 뛰어난 내충격성과 높은 토크 밀도로 최근 보행 로봇과 소형 액추에이터 분야에서 다시 주목받고 있는 <strong>Cycloidal Drive</strong>에 대해 알아보겠습니다.</p> <p>Cycloidal Drive는 특유의 <strong>Eccentric (편심)</strong> 입력과 그에 따른 사이클로이드 궤적을 이용하여 감속과 토크 증폭을 달성하는 기계 장치입니다. Cycloid Teeth Geometry에 따라 감속비가 결정되며, 매우 컴팩트한 크기에서 높은 토크를 낼 수 있고 무엇보다 충격에 매우 강한 구조적 특성을 가집니다.</p> <h2 id="작동-원리와-감속비">작동 원리와 감속비</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/cycloid_motion-480.webp 480w,/assets/img/hardware/cycloid_motion-800.webp 800w,/assets/img/hardware/cycloid_motion-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/cycloid_motion.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> Cycloidal Reduction의 작동 예시 [1] </div> </div> </div> <p>Cycloidal Drive의 작동 원리는 크게 세 단계의 메커니즘으로 이루어집니다.</p> <ol> <li><strong>Eccentric Input:</strong> 모터와 연결된 입력축(Input shaft)에 편심 베어링이 결합되어 있어, 입력축이 회전하면 중심축을 벗어난 Eccentric motion을 만들어냅니다.</li> <li><strong>Cycloid Motion:</strong> 이 편심 베어링에 끼워진 Cycloid Disk는 하우징의 바깥쪽 핀(Ring pins)들과 맞물리며 사이클로이드 궤적을 따라 구르듯 흔들리며 회전합니다.</li> <li><strong>Output Extraction:</strong> Disk에 뚫린 구멍들을 통해 Output shaft의 핀들이 연결되어, Disk의 느린 자전 운동만을 출력축으로 전달합니다.</li> </ol> <h3 id="고정-축에-따른-감속비-gear-ratio">고정 축에 따른 감속비 (Gear Ratio)</h3> <p>Cycloidal Drive는 어떤 요소를 고정하느냐에 따라 감속비와 회전 방향이 달라집니다. 하우징의 핀 개수를 N, Cycloid Disk의 톱니(Lobe) 개수를 N-1이라고 할 때:</p> <ul> <li> <p><strong>하우징(Outer Ring) 고정 / Disk 출력:</strong> 입력축이 1회전할 때, Disk는 톱니 1개 분량만큼 입력축과 <strong>역방향</strong>으로 회전합니다. Gear Ratio = (N - 1) / 1</p> <figure> <iframe width="720" height="405" src="https://www.youtube.com/embed/L6sBhsO_UNA" title="Cycloidal Drive - Fixed Ring" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""> </iframe> <figcaption style="text-align: center;"> <em>Cycloidal Drive — Fixed Ring (short)</em> </figcaption> </figure> </li> <li> <p><strong>Disk 고정 / 하우징(Outer Ring) 출력:</strong> 입력축이 1회전할 때, 하우징이 핀 1개 분량만큼 입력축과 <strong>정방향</strong>으로 회전합니다. Gear Ratio = N / 1</p> <figure> <iframe width="720" height="405" src="https://www.youtube.com/embed/7WD3s8bxU5c" title="Cycloidal Drive - Fixed Shaft" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""> </iframe> <figcaption style="text-align: center;"> <em>Cycloidal Drive — Fixed Shaft (short)</em> </figcaption> </figure> </li> </ul> <h2 id="2-접촉-메커니즘-설계-rolling-vs-sliding-contact">2. 접촉 메커니즘 설계: Rolling vs. Sliding Contact</h2> <p>기어 이빨의 마찰로 동력을 전달하는 일반적인 기어와 달리, Cycloidal Drive는 기구학적인 구속 조건(Kinematic Constraint)에 의해 궤적이 완전히 결정됩니다. 따라서 설계 목적에 따라 <strong>Rolling Contact</strong>과 <strong>Sliding Contact</strong> 두 가지 방식을 모두 적용할 수 있습니다.</p> <h3 id="rolling-contact-구름-접촉">Rolling Contact (구름 접촉)</h3> <p>하우징 핀이나 출력 핀 위치에 베어링이나 원통형 롤러를 추가하여 마찰을 최소화하는 방식입니다.</p> <ul> <li><strong>특징:</strong> 마찰 손실이 극히 적어 전달 효율이 매우 높고 발열이 적습니다.</li> <li><strong>한계:</strong> 소형화가 어렵습니다. 높은 감속비를 얻으려면 롤러의 개수가 늘어나야 하는데, 이는 곧 부품 수 증가와 감속기 전체 무게의 급격한 상승으로 이어집니다.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/rolling_contact_cycloid-480.webp 480w,/assets/img/hardware/rolling_contact_cycloid-800.webp 800w,/assets/img/hardware/rolling_contact_cycloid-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/rolling_contact_cycloid.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> Rolling Conract Cycloid [2] </div> </div> </div> <h3 id="sliding-contact-미끄럼-접촉">Sliding Contact (미끄럼 접촉)</h3> <p>별도의 롤러 없이 Cycloid Disk의 형상 자체가 하우징이나 출력 핀과 직접 맞닿아 미끄러지며 구동하는 방식입니다.</p> <ul> <li><strong>특징:</strong> 롤러가 생략되므로 구조가 매우 단순해지고 극한의 소형화 및 경량화가 가능합니다.</li> <li><strong>한계:</strong> Sliding Friction(미끄럼 마찰)이 크게 발생하여 동력 전달 효율이 현저히 떨어지고 마모에 취약합니다.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/sliding_contact_cycloid-480.webp 480w,/assets/img/hardware/sliding_contact_cycloid-800.webp 800w,/assets/img/hardware/sliding_contact_cycloid-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/sliding_contact_cycloid.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> Sliding Contact Cycloid [3] </div> </div> </div> <p>실제 액추에이터 설계에서는 하중이 가장 크게 걸리는 중앙의 Eccentric shaft 부위에는 베어링을 삽입하여 Rolling Contact을 구현하고, 상대적으로 선속도가 낮은 감속기 외부의 Disk와 하우징 사이에는 Sliding Contact을 적용합니다.</p> <p>이때 Sliding Contact의 높은 마찰과 마모 문제를 해결하기 위해, Cycloid Disk 자체를 금속 대신 <strong>Delrin (POM)</strong>이나 <strong>Nylon</strong> 같은 저마찰 특성의 엔지니어링 플라스틱으로 가공하여 마찰 손실을 줄이기도 합니다.</p> <h2 id="3-장점-advantages">3. 장점 (Advantages)</h2> <h4 id="1-높은-토크-밀도">1. 높은 토크 밀도</h4> <p>Harmonic Drive와 유사하게 매우 작은 체적으로도 큰 토크를 생성할 수 있어, 관절의 패키징을 컴팩트하게 구성할 수 있습니다.</p> <h4 id="2-높은-내충격성">2. 높은 내충격성</h4> <p>Spur gear가 1~2개의 치형으로 토크를 감당하는 반면, Cycloidal Drive는 구조적으로 전체 치형의 약 <strong>30~50%</strong>가 동시에 하중을 분담합니다 (Load Distribution). 따라서 외부 충격 부하(Shock Load)가 분산되어 기어가 파손되지 않으며, 보행 로봇의 발구름이나 조작 로봇의 충돌 상황 등 반복적인 충격이 가해지는 시스템에 매우 적합합니다.</p> <h4 id="3-단일-스테이지-고감속비">3. 단일 스테이지 고감속비</h4> <p>단일 스테이지 구조만으로 50:1에서 100:1 이상의 높은 감속비를 달성할 수 있어, 다단 감속기로 인한 부피 증가와 시스템 복잡성을 줄일 수 있습니다.</p> <h2 id="4-단점-및-설계-고려사항">4. 단점 및 설계 고려사항</h2> <h4 id="1-가공-난이도">1. 가공 난이도</h4> <p>부품 수가 적어 보이지만, 구조가 작동하기 위한 가공 난이도는 매우 높습니다. 정밀한 사이클로이드 곡선을 오차 없이 구현해야 하므로 고정밀 CNC 가공이 필수적이며, 조립 과정에서도 높은 숙련도가 요구됩니다.</p> <h4 id="2-공차-민감도">2. 공차 민감도</h4> <p>공차(Tolerance)나 조립 불량도 전체 시스템의 성능 저하로 직결됩니다. 공차가 좁으면 <strong>Jamming(물림)</strong> 현상이 발생하여 구동이 불가능해지고, 공차가 넓으면 <strong>Backlash</strong>가 발생하여 위치 정밀도가 떨어집니다.</p> <h4 id="3-profile-modification">3. Profile Modification</h4> <p>편심량(Eccentricity)은 Cycloid Profile의 곡률과 Kinematic Constraint를 결정하는 핵심 변수입니다. 이론적인 사이클로이드 곡선을 그대로 가공하면 조립 공차나 열팽창에 의해 물림 현상이 발생하기 쉽습니다. 따라서 곡선의 크기를 미세하게 줄이거나 수정하는 <strong>Profile Modification</strong> 과정이 반드시 필요하며, 이는 설계의 복잡도를 급격히 높이는 원인이 됩니다.</p> <h4 id="4-질량-불균형과-진동">4. 질량 불균형과 진동</h4> <p>Eccentric motion을 하는 Disk의 질량 중심이 계속 이동하므로 고속 회전 시 심각한 진동이 발생합니다. 이를 상쇄하기 위해 일반적으로 위상이 180도 차이 나는 <strong>두 개의 Cycloid Disk(Dual-disk)를 겹쳐서 사용</strong>하는데, 이 경우 무게와 부피가 추가로 증가하게 됩니다.</p> <p><a href="/hardware06-kr/">다음 포스트 : [로봇 하드웨어 06] - 엑추에이터(5): QDD 엑추에이터</a></p> <h3 id="references">References</h3> <p>[1] https://mevirtuoso.com/become-a-member-cycloidal/</p> <p>[2] https://www.youtube.com/watch?v=KX9Mx8ghtio</p> <p>[3] https://www.youtube.com/watch?v=yBckAoqNQx4</p>]]></content><author><name></name></author><category term="Hardware"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - 사이클로이드 감속기]]></summary></entry><entry><title type="html">[로봇 하드웨어 04] - 엑추에이터 (3): 유성기어 감속기</title><link href="https://dokkev.github.io/hardware04-kr/" rel="alternate" type="text/html" title="[로봇 하드웨어 04] - 엑추에이터 (3): 유성기어 감속기"/><published>2025-12-04T00:00:00+00:00</published><updated>2025-12-04T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-04-kr</id><content type="html" xml:base="https://dokkev.github.io/hardware04-kr/"><![CDATA[<p>이번 포스트에서는 <strong>유성기어 감속기 (Planetary Gearbox)</strong>에 대해 알아보겠습니다. 앞서 다룬 Harmonic Drive가 큰 감속비와 높은 위치 정밀도에 강점이 있다면, Planetary Gearbox는 정밀함보다는 <strong>높은 강성(Stiffness)과 내구성(Durability)</strong>, 즉 물리적으로 버티는 힘에 최적화된 감속기입니다.</p> <h2 id="유성기어-감속기의-원리">유성기어 감속기의 원리</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/pg-480.webp 480w,/assets/img/hardware/pg-800.webp 800w,/assets/img/hardware/pg-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/pg.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> 유성기어 구조 [1] </div> </div> </div> <p>Planetary Gearbox는 태양계의 공전 운동을 모사한 구조를 가지고 있으며, 다음 네 가지 핵심 요소로 구성됩니다.</p> <ol> <li><strong>Sun Gear (태양 기어):</strong> 중심에 위치한 입력 기어입니다.</li> <li><strong>Planet Gears (유성 기어):</strong> Sun Gear 주위를 돌며 맞물리는 다수의 기어입니다.</li> <li><strong>Ring Gear (링 기어):</strong> 시스템의 외곽을 감싸는 내부 치형(Internal Gear) 기어입니다.</li> <li><strong>Carrier (캐리어):</strong> 다수의 Planet Gear를 묶어주며, 보통 출력축 역할을 합니다.</li> </ol> <h3 id="핵심은-하중-분산-load-distribution">핵심은 하중 분산 (Load Distribution)</h3> <p>이 구조의 가장 중요한 특징은 <strong>Load Distribution</strong>입니다. 일반적인 Spur Gear 시스템에서는 단 하나의 접촉점(Contact patch)이 모든 토크를 감당해야 합니다. 반면, Planetary Gearbox는 여러 개의 Planet Gear가 동시에 맞물리며 <strong>토크와 접촉 응력(Contact Stress)을 분산</strong>시킵니다.</p> <p>Planet Gear의 개수를 $N$이라 할 때, 이상적인 환경에서는 각 기어가 전체 토크의 $1/N$만큼만 부담하게 됩니다.</p> <p>물론 현실적으로는 가공 오차나 베어링 유격 등으로 인해 완벽한 균등 분산은 어렵지만, 단일 기어 대비 치면압(Surface Pressure)이 획기적으로 낮아지는 것은 분명합니다.</p> <p>이로 인한 이점은 다음과 같습니다.</p> <ul> <li><strong>높은 토크 밀도:</strong> 작은 부피로 큰 토크를 전달할 수 있습니다.</li> <li><strong>내충격성:</strong> 외부 충격(Shock Load)이 여러 기어로 분산되어 파손 위험이 적습니다.</li> <li><strong>피로 수명 증대:</strong> 개별 기어 이빨이 받는 스트레스가 줄어듭니다.</li> </ul> <p>이러한 특성 때문에 Planetary Gearbox는 <strong>힘 제어(Force Control)</strong>가 중요하거나 거친 환경에서 구동되는 <strong>동적 로봇(예: 휴머노이드, 4족 보행 로봇)</strong>의 관절 액추에이터로 널리 사용됩니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/pg-compare-480.webp 480w,/assets/img/hardware/pg-compare-800.webp 800w,/assets/img/hardware/pg-compare-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/pg-compare.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> 유성기어 감속기 동작 예시 [1] </div> </div> </div> <h2 id="감속비-계산">감속비 계산</h2> <p>Planetary Gearbox는 Sun, Ring, Carrier 중 어느 요소를 고정(Fixed)하고 어느 요소를 입력/출력으로 쓰느냐에 따라 다양한 감속비와 회전 방향을 만들어낼 수 있습니다.</p> <p>다관절 로봇에서 가장 보편적으로 사용되는 구성은 다음과 같습니다:</p> <ul> <li><strong>Ring Gear:</strong> 고정 (Fixed)</li> <li><strong>Sun Gear:</strong> 입력 (Input)</li> <li><strong>Carrier:</strong> 출력 (Output)</li> </ul> <p>이 구성에서의 감속비 공식은 다음과 같습니다.</p> \[\text{Gear Ratio} = \frac{\omega_{in}}{\omega_{out}} = 1 + \frac{N_{ring}}{N_{sun}}\] <p>여기서:</p> <ul> <li>$N_{ring}$ : Ring Gear의 이빨 수 (Teeth count)</li> <li>$N_{sun}$ : Sun Gear의 이빨 수</li> </ul> <p><strong>예시:</strong></p> <ul> <li>Sun Gear = 20 teeth</li> <li>Ring Gear = 80 teeth</li> </ul> \[\text{Gear Ratio} = 1 + \frac{80}{20} = 1 + 4 = 5:1\] <p>이처럼 Planetary Gearbox는 기어의 이빨 수 비율에 ‘+1’이 더해지는 구조적 특성을 가집니다.</p> <hr/> <h2 id="장점">장점</h2> <h4 id="1-높은-구조적-안정성">1. 높은 구조적 안정성</h4> <p>다수의 Planet Gear가 부하를 분담하므로 High Torque를 반복적으로 전달하는 데 유리합니다. 특히 Harmonic Drive와 달리 얇고 유연한 부품이 없으므로, <strong>충격 하중(Shock Load)</strong>에 대한 신뢰성이 매우 높습니다.</p> <h4 id="2-비용-효율성">2. 비용 효율성</h4> <p>특수 소재나 정밀한 탄성 설계가 필요한 Harmonic Drive나 사이클로이드 감속기(Cycloidal Drive)에 비해, 일반적인 Spur Gear 가공 공정을 활용할 수 있어 제작 비용이 상대적으로 저렴합니다.</p> <h4 id="3-유지보수-용이성">3. 유지보수 용이성</h4> <p>구조가 직관적이고 피로 파괴를 전제로 한 변형 부품이 없기 때문에, 적절한 윤활(Lubrication)만 이루어진다면 장기적인 수명 예측과 유지보수가 수월합니다.</p> <hr/> <h2 id="단점-및-한계">단점 및 한계</h2> <h4 id="1-제한적인-감속비-scalability-limit">1. 제한적인 감속비 (Scalability Limit)</h4> <p>Planetary Gearbox는 기하학적 구조상 <strong>단일 스테이지(Single Stage)</strong>에서 구현할 수 있는 감속비에 한계가 있습니다.</p> <ul> <li>Sun Gear가 너무 작아지거나 Ring Gear가 너무 커져야 하기 때문입니다.</li> <li>통상적으로 스테이지당 <strong>3:1 ~ 10:1</strong> 수준이 한계입니다.</li> </ul> <p>더 높은 감속비가 필요하면 스테이지를 직렬로 쌓아야(Multi-stage) 하는데, 이 경우 전체 길이가 길어지고 무게가 증가하며, <strong>마찰 손실(Friction Loss)</strong>과 <strong>Backlash</strong>가 누적되어 성능이 저하됩니다.</p> <h4 id="2-백래시-backlash">2. 백래시 (Backlash)</h4> <p>대부분의 Planetary Gearbox는 금속 강체인 Spur Gear를 사용합니다. 기어의 원활한 회전을 위해서는 이빨 사이에 최소한의 틈(Clearance)이 필수적이므로, 구조적으로 <strong>Backlash</strong>를 피하기 어렵습니다. 이는 로봇의 정밀 위치 제어를 방해하는 요소가 됩니다.</p> <h3 id="개선책-헬리컬-기어-helical-gear">개선책: 헬리컬 기어 (Helical Gear)</h3> <p>Spur Gear의 소음과 진동, 그리고 Backlash 문제를 줄이기 위해 <strong>헬리컬 기어(Helical Gear)</strong>를 사용하기도 합니다. 헬리컬 기어는 이빨이 사선으로 배치되어 있어, 여러 이빨이 점진적으로 부드럽게 맞물립니다(High Contact Ratio).</p> <p>하지만 여기에도 <strong>Trade-off</strong>가 존재합니다.</p> <ol> <li><strong>축 방향 하중 (Axial Force):</strong> 이빨의 경사각 때문에 회전 시 축을 밀어내는 힘(Thrust force)이 발생합니다. 이를 버티기 위해 고가의 <strong>Thrust Bearing</strong>이 추가로 필요하며 하우징 설계가 복잡해집니다.</li> <li><strong>효율 저하:</strong> Axial force로 인한 마찰 증가로 동력 전달 효율이 Spur Gear 대비 소폭 감소할 수 있습니다.</li> </ol> <p>이를 해결하기 위해 축 방향 힘을 상쇄시키는 <strong>이중 헬리컬(Double Helical / Herringbone)</strong> 구조를 사용하기도 하지만, 이는 가공 난이도와 비용을 급격히 상승시킵니다.</p> <p><a href="/hardware05-kr/">다음 포스트 : [로봇 하드웨어 05] - 엑추에이터(4): 사이클로이드 감속기</a></p> <h3 id="references">References</h3> <p>[1] https://www.tec-science.com/mechanical-power-transmission/planetary-gear/epicyclic-planetary-gear/</p>]]></content><author><name></name></author><category term="Hardware"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - 유성기어 감속기]]></summary></entry><entry><title type="html">[로봇 하드웨어 03] - 엑추에이터 (2): 하모닉 드라이브 감속기</title><link href="https://dokkev.github.io/hardware03-kr/" rel="alternate" type="text/html" title="[로봇 하드웨어 03] - 엑추에이터 (2): 하모닉 드라이브 감속기"/><published>2025-12-03T00:00:00+00:00</published><updated>2025-12-03T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-03-kr</id><content type="html" xml:base="https://dokkev.github.io/hardware03-kr/"><![CDATA[<p>감속기(Reducer)는 모터의 <strong>고속·저토크</strong> 출력을 로봇 관절 구동에 필요한 <strong>저속·고토크</strong>로 변환하는 기계 장치입니다. 일반적인 BLDC 모터는 회전 속도는 빠르지만 토크가 부족하기 때문에, 로봇 팔을 구동하기 위해서는 감속기가 필수적입니다.</p> <p>다양한 감속기 중에서도, <strong>Harmonic Drive</strong>, 기술적 명칭으로 <strong>Strain Wave Gearing</strong>은 협동 로봇과 정밀 로봇 팔에서 표준적으로 사용됩니다.</p> <h2 id="작동-원리">작동 원리</h2> <p>Harmonic Drive 는 강체(Rigid body) 간의 치합이 아닌, <strong>탄성 변형(Elastic Deformation)</strong>을 이용해 동력을 전달한다는 점에서 기존 기어와 구별됩니다.</p> <p>주요 구성 요소는 다음 세 가지입니다.</p> <ol> <li><strong>Wave Generator (Input):</strong> 타원형 캠에 얇은 베어링이 결합된 형태입니다. 모터 축과 연결되어 회전하며 Flexspline을 타원형으로 변형시킵니다.</li> <li><strong>Flexspline (Output):</strong> 얇은 컵 모양의 금속 기어입니다. 탄성을 가지고 있어 반복적으로 변형되며, 출력축과 연결됩니다.</li> <li><strong>Circular Spline (Fixed):</strong> 강성이 높은 외곽 링 기어입니다. 내부에 이빨이 있으며, Flexspline보다 이빨 개수가 통상 2개 더 많습니다.</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/hd-480.webp 480w,/assets/img/hardware/hd-800.webp 800w,/assets/img/hardware/hd-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/hd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/hd-480.webp 480w,/assets/img/hardware/hd-800.webp 800w,/assets/img/hardware/hd-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/hd.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="감속비-계산">감속비 계산</h3> <p>Wave Generator가 회전하면 타원의 장축 부분에서 Flexspline과 Circular Spline이 맞물립니다. 이때 두 기어의 이빨 수(Tooth Count) 차이로 인해 상대 회전이 발생합니다.</p> <p>예를 들어:</p> <ul> <li><strong>Flexspline:</strong> 200 teeth</li> <li><strong>Circular Spline:</strong> 202 teeth</li> </ul> <p>입력축인 Wave Generator가 1회전 할 때, Flexspline은 Circular Spline의 전체 이빨 수(202개)를 다 돌지 못하고 차이만큼인 <strong>2 teeth 만큼 역방향으로 회전</strong>하게 됩니다.</p> <p>이를 감속비로 계산하면 다음과 같습니다.</p> \[\text{Gear Ratio} = \frac{-N_{flex}}{N_{circular} - N_{flex}} = \frac{-200}{202 - 200} = -100:1\] <p>이러한 원리로 단일 스테이지에서 <strong>100:1</strong> 이상의 고감속비를 구현할 수 있습니다.</p> <hr/> <h2 id="장점">장점</h2> <h4 id="1-소형화-및-높은-토크-밀도">1. 소형화 및 높은 토크 밀도</h4> <p>동급의 유성 기어(Planetary Gear) 대비 부피와 무게가 작습니다.</p> <ul> <li>관절 모듈의 소형화 가능</li> <li>로봇 링크의 관성(Inertia) 감소 이는 로봇 전체의 동역학(Dynamics) 성능 향상으로 이어집니다.</li> </ul> <h4 id="2-백래시-제로-zero-backlash">2. 백래시 제로 (Zero Backlash)</h4> <p>Harmonic Drive는 Flexspline이 Circular Spline에 예압(Pre-load) 된 상태로 구동되므로 기계적인 <strong>Backlash</strong>가 사실상 없습니다.</p> <ul> <li><strong>높은 반복 정밀도(High Repeatability):</strong> 로봇 팔 끝단의 위치 오차를 최소화할 수 있습니다.</li> <li>다관절 로봇에서 각 관절의 Backlash가 누적되어 말단 오차가 증폭되는 문제를 해결하는 핵심 요소입니다.</li> </ul> <figure> <iframe width="720" height="405" src="https://www.youtube.com/embed/8fYwUV6QV8c" title="What is Backlash?" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""> </iframe> <figcaption style="text-align: center;"> <em>기어 백래시</em> </figcaption> </figure> <hr/> <h2 id="단점-및-한계">단점 및 한계</h2> <h4 id="1-피로-수명-fatigue-life">1. 피로 수명 (Fatigue Life)</h4> <p>Flexspline은 얇은 금속 박판으로, 구동 중 지속적인 타원 변형을 반복합니다. 구조적으로 <strong>저주기 피로(Low-cycle Fatigue)</strong> 환경에 노출되어 있으며, 이는 감속기의 전체 수명을 결정짓는 주요 인자입니다.</p> <h4 id="2-충격에-취약함-ratcheting">2. 충격에 취약함 (Ratcheting)</h4> <p>외부 충격(Shock Load)에 매우 취약합니다. 충돌 등으로 인해 순간 최대 토크(Momentary Peak Torque)를 초과하는 과도한 힘이 가해질 경우, Flexspline의 이빨이 탄성 한계를 넘어 Circular Spline의 이빨을 타고 넘는 <strong>Ratcheting</strong> 현상이 발생합니다. 이 경우 기어 이빨의 영구 변형이나 파손(Buckling)이 발생하여 감속기를 교체해야 합니다.</p> <h4 id="3-낮은-강성-wind-up">3. 낮은 강성 (Wind-up)</h4> <p>Backlash는 없지만, 기구적인 강성(Stiffness)은 상대적으로 낮습니다. Flexspline이 비틀림 하중(Torsional load)에 대해 스프링처럼 비틀리는 <strong>Wind-up</strong> 현상이 발생합니다. 이는 높은 게인(High Gain) 제어 시 <strong>공진(Resonance)</strong>을 유발하거나 제어 대역폭(Control Bandwidth)을 제한하는 요인이 됩니다.</p> <hr/> <h2 id="보완-설계-sea--torque-sensor">보완 설계: SEA &amp; Torque Sensor</h2> <p>Harmonic Drive의 낮은 내충격성과 강성 특성을 보완하기 위해, 로봇 관절 설계 시 출력축에 <strong>Torque Sensor</strong>를 배치하여 충돌을 감지하거나, 의도적인 탄성 요소를 추가한 <strong>Series Elastic Actuator (SEA)</strong> 구조를 사용하기도 합니다. SEA 는 나중에 자세히 다루도록 하겠습니다.</p> <p><a href="/hardware04-kr/">다음 포스트 : [로봇 하드웨어 04] - 엑추에이터(3): 유성 기어</a></p> <h3 id="references">References</h3> <p>이 포스트 하모닉 드라이브에 대한 내용은 [2]의 자료를 참고하여 작성되었습니다.</p> <p>[1] https://www.harmonicdrive.net/_hd/content/documents/FBB_DifferentialGear.pdf</p> <p>[2] https://www.cubemars.com/product/ak10-9-v2-0-kv60-robotic-actuator.html</p>]]></content><author><name></name></author><category term="Hardware"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - 하모닉 드라이브]]></summary></entry><entry><title type="html">[로봇 하드웨어 02] - 엑추에이터 (1): BLDC 모터</title><link href="https://dokkev.github.io/hardware02-kr/" rel="alternate" type="text/html" title="[로봇 하드웨어 02] - 엑추에이터 (1): BLDC 모터"/><published>2025-12-02T00:00:00+00:00</published><updated>2025-12-02T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-02-kr</id><content type="html" xml:base="https://dokkev.github.io/hardware02-kr/"><![CDATA[<h2 id="엑추에이터란-무엇인가">엑추에이터란 무엇인가?</h2> <p>엑추에이터(Actuator)는 로봇을 실제로 움직이게 만드는 구동 부품입니다. 센서가 환경을 인지하고 제어기가 판단을 내린다면, 엑추에이터는 그 신호를 물리적인 힘과 운동으로 바꾸는 역할을 합니다.</p> <h3 id="사전적-정의와-로봇-하드웨어의-차이">사전적 정의와 로봇 하드웨어의 차이</h3> <p>사전적인 의미로 엑추에이터는 “시스템에 물리적 움직임을 발생시키는 장치”를 통칭합니다. 이 정의에 따르면 다음의 요소들이 모두 포함됩니다.</p> <ul> <li>유압 및 공압 실린더</li> <li>피에조 소자</li> <li>감속기가 없는 순수 전기 모터</li> </ul> <p>즉, 사전적으로는 모터 단품만 있어도 엑추에이터라고 부를 수 있습니다. 하지만 <strong>로봇 하드웨어의 문맥</strong>에서 통용되는 의미는 이와 조금 다릅니다.</p> <h3 id="로봇에서의-엑추에이터-모터와-감속기의-결합">로봇에서의 엑추에이터: 모터와 감속기의 결합</h3> <p>다관절 로봇, 특히 매니퓰레이터나 보행 로봇에서는 모터 단독으로 관절을 직접 구동하는 경우가 드뭅니다. 대부분의 전기 모터는 고속 회전에 특화되어 있어, <strong>감속기(Reducer)</strong>를 통해 속도를 줄이고 토크를 증폭시켜야만 로봇 관절을 지탱할 수 있기 때문입니다.</p> <p>따라서 로봇 개발이나 하드웨어 설계 관점에서 “엑추에이터”라 함은 통상적으로 <strong>[전기 모터 + 감속기]가 하나로 통합된 구동 모듈</strong>을 지칭합니다.</p> <h3 id="왜-이-구분이-중요한가">왜 이 구분이 중요한가?</h3> <p>이 조합 방식이 곧 로봇의 <strong>출력 임피던스(Output Impedance), 역구동성(Backdrivability), 그리고 제어 대역폭 (Control Bandwidth)</strong>을 결정하기 때문입니다.</p> <p>같은 제어 알고리즘을 사용하더라도, 모터와 감속기가 어떻게 구성되느냐에 따라 로봇의 움직임과 접촉 반응은 완전히 달라집니다. 사실상 로봇의 물리적 성능의 반은 엑추에이터 구성에서 결정된다고 해도 과언이 아닙니다.</p> <p>물론 로봇 분야에는 공압식이나 소프트 액추에이터 등 다양한 방식이 존재하지만, 본 시리즈에서는 가장 보편적인 <strong>전기 모터 기반의 엑추에이터</strong>에 집중하려 합니다.</p> <p>감속기의 복잡한 세계는 다음 포스트에서 다루기로 하고, 이번 글에서는 로봇 구동의 심장인 <strong>모터(Motor)</strong>가 어떤 구조와 특성을 가지는지 먼저 살펴보겠습니다.</p> <h2 id="모터란-무엇인가-제어-가능한-토크의-원천">모터란 무엇인가: 제어 가능한 토크의 원천</h2> <p>로봇 하드웨어를 논할 때 흔히 “이 모터 성능이 얼마나 좋은가?”라는 질문을 던집니다.</p> <p>일반적인 기계라면 ‘최대 출력’이나 ‘최대 회전수’가 기준이겠지만, 로봇 공학의 관점에서는 조금 다릅니다. 여기서 “좋은 모터”란 단순히 큰 힘을 내는 모터가 아니라, <strong>“얼마나 예측 가능하고, 빠르고, 일관되게 힘을 낼 수 있는가”</strong>를 의미합니다.</p> <p>즉, 로봇 액추에이터의 관점에서 모터는 단순히 ‘회전하는 부품’이 아닙니다. <strong>전류(Current)라는 입력값을 받아, 원하는 시점에 원하는 만큼의 토크(Torque)를 뱉어내는 ‘제어 가능한 힘의 원천’</strong>으로 다뤄집니다.</p> <h3 id="구동-원리-자석과-코일의-상호작용">구동 원리: 자석과 코일의 상호작용</h3> <p>모터는 기본적으로 전기 에너지를 기계적인 회전 운동으로 바꾸는 장치입니다. 그 내부에는 두 가지 핵심 요소가 존재합니다.</p> <ol> <li><strong>영구자석 (Permanent Magnet):</strong> 고정된 자기장을 형성합니다.</li> <li><strong>코일 (Coil):</strong> 전류가 흐를 때 전자석이 되어 또 다른 자기장을 만듭니다.</li> </ol> <p>원리는 간단합니다. 고정된 영구자석 사이에 있는 코일에 전류를 흘려보내면, 앙페르의 법칙에 의해 코일 주변에 자기장이 생성됩니다. 이 <strong>‘전류가 만든 자기장’과 ‘영구자석의 자기장’이 서로 밀어내거나 당기는 힘(로렌츠 힘, Lorentz Force)</strong>이 발생하고, 이 힘이 회전축을 중심으로 작용하여 <strong>토크(Torque)</strong>를 만들어냅니다.</p> <p>이때 힘의 크기와 방향은 전류의 세기와 방향에 의해 결정됩니다. 즉, <strong>우리가 코일에 흘려보내는 전류를 조절함으로써, 모터가 내는 토크를 정밀하게 제어</strong>할 수 있게 되는 것입니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/bldc-480.webp 480w,/assets/img/hardware/bldc-800.webp 800w,/assets/img/hardware/bldc-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/bldc.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> BLDC 모터의 작동 원리 [1] </div> </div> </div> <h2 id="bldc-모터-brushless-dc-motor">BLDC 모터 (Brushless DC Motor)</h2> <p>모터에는 스텝 모터, 유도 전동기 등 여러 종류가 있지만, 고성능 다관절 로봇의 엑추에이터로는 <strong>BLDC (Brushless DC) 모터</strong>가 사실상의 표준으로 자리 잡았습니다.</p> <h3 id="구조와-작동-원리-브러시를-없애고-전자-제어를-더하다">구조와 작동 원리: 브러시를 없애고 전자 제어를 더하다</h3> <p>BLDC 모터는 이름 그대로 ‘브러시(Brush)’가 없는 DC 모터입니다.</p> <p>기존의 DC 모터는 회전하는 축에 전기를 공급하기 위해 물리적인 브러시와 정류자가 필요했습니다. 하지만 BLDC는 이 물리적 접촉부를 과감히 없애고, <strong>스테이터(Stator, 고정자)</strong>에 코일을, <strong>로터(Rotor, 회전자)</strong>에 영구자석을 배치하는 뒤집힌 구조를 가집니다.</p> <p>핵심은 <strong>‘전류의 분배’</strong>입니다. 브러시가 하던 역할을 제어기(드라이버/인버터)가 대신합니다. 스테이터에 배치된 여러 상(Phase)의 코일에 전류를 시간적으로 정밀하게 분배하여, <strong>회전하는 자기장(Rotating Magnetic Field)</strong>을 만들어냅니다. 로터의 자석은 이 회전 자기장을 따라가며 돌게 됩니다.</p> <h3 id="왜-bldc인가">왜 BLDC인가?</h3> <p>이러한 구조적 차이는 로봇 제어에 있어 결정적인 이점을 제공합니다.</p> <ol> <li><strong>높은 효율과 내구성:</strong> 물리적으로 마찰을 일으키는 브러시가 없기 때문에 마찰 손실이 적고, 브러시 마모로 인한 유지보수가 필요 없습니다.</li> <li><strong>정밀한 토크 제어:</strong> 기계적인 접촉 없이 전기 신호만으로 자기장의 방향과 세기를 조절하므로, 매우 빠른 응답 속도와 정밀한 토크 제어가 가능합니다.</li> </ol> <h2 id="bldc-모터의-구조-inner-vs-outer-runner">BLDC 모터의 구조: Inner vs Outer Runner</h2> <p>BLDC 모터의 내부는 크게 <strong>스테이터(Stator)</strong>와 <strong>로터(Rotor)</strong>로 구분됩니다.</p> <ul> <li><strong>스테이터 (Stator, 고정자):</strong> 말 그대로 정지된 구조물입니다. 코일이 감겨 있어 전류가 흐르면 시간에 따라 회전하는 자기장을 만들어냅니다. 모터 제어의 핵심인 ‘전류 분배’가 일어나는 곳입니다.</li> <li><strong>로터 (Rotor, 회전자):</strong> 회전하는 구조물입니다. 영구자석이 부착되어 있어, 스테이터가 만든 자기장을 따라 에너지가 가장 낮은 방향으로 정렬하려는 힘(인력/척력)을 받아 회전합니다.</li> </ul> <p>이때, <strong>“로터가 스테이터의 안쪽에 있느냐, 바깥쪽에 있느냐”</strong>에 따라 모터의 특성이 달라집니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/bldc_type-480.webp 480w,/assets/img/hardware/bldc_type-800.webp 800w,/assets/img/hardware/bldc_type-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/bldc_type.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> BLDC 모터의 종류 [2] </div> </div> </div> <h3 id="1-inner-runner-내전형">1) Inner Runner (내전형)</h3> <p>로터가 중심부에 있고, 스테이터가 이를 감싸는 구조입니다.</p> <p><strong>특징:</strong></p> <ul> <li><strong>작은 회전 관성:</strong> 회전체(로터)의 지름이 작아 관성 모멘트가 낮습니다. 덕분에 가속과 감속이 빠릅니다.</li> <li><strong>고속 회전 유리:</strong> 구조적으로 안정적이라 수천~수만 RPM의 고속 회전에 적합합니다.</li> <li><strong>낮은 토크:</strong> 회전 반경이 작아 동일한 전자기력으로 낼 수 있는 토크는 상대적으로 작습니다.</li> </ul> <p><strong>활용:</strong> 이 모터는 <strong>“고속 회전 + 높은 감속비”</strong> 조합에 최적화되어 있습니다. 모터 자체는 작고 빠르게 돌리면서, 50:1 이상의 높은 기어비를 가진 감속기(Harmonic Drive 등)를 통해 토크를 증폭시킵니다. 따라서 <strong>높은 위치 정밀도와 컴팩트한 관절</strong>이 요구되는 <strong>산업용 로봇 팔이나 협동 로봇(Cobot)</strong>에 주로 사용됩니다.</p> <h3 id="2-outer-runner-외전형">2) Outer Runner (외전형)</h3> <p>로터가 바깥쪽에 있고, 스테이터가 안쪽에 위치한 구조입니다.</p> <p><strong>특징:</strong></p> <ul> <li><strong>큰 토크 생성:</strong> 힘이 작용하는 작용점(Air gap)의 반지름이 큽니다. 지렛대 원리처럼, 같은 전자기력이라도 반지름이 크면 더 큰 토크를 냅니다.</li> <li><strong>단순한 구조:</strong> 코일을 감을 공간이 넉넉하고, 다극(Multi-pole) 설계에 유리합니다.</li> <li><strong>큰 회전 관성:</strong> 회전체가 크고 무거워 고속 회전보다는 저속-고토크 구동에 유리합니다.</li> </ul> <p><strong>활용:</strong> 이 모터는 <strong>“저속 고토크 + 낮은 감속비(혹은 직구동)”</strong> 조합에서 빛을 발합니다. 감속기의 기어비를 낮추면(10:1 이하), 로봇 관절의 <strong>기계적 임피던스(마찰, 관성)가 낮아져 역구동성(Backdrivability)이 극대화</strong>됩니다. 즉, 로봇이 외부 충격을 유연하게 흡수하거나, 지면 반발력을 민감하게 제어할 수 있게 됩니다.동적 제어가 중요한 <strong>보행 로봇의 QDD 액추에이터</strong>에 주로 사용됩니다.</p> <hr/> <h2 id="모터-네이밍과-외관">모터 네이밍과 외관</h2> <p>드론이나 로봇용으로 판매되는 Off-the-shelf 모터들을 살펴보면, 모델명에 숫자가 포함된 경우가 많습니다. 이 숫자는 단순한 일련번호가 아니라 모터의 <strong>직경(Diameter)</strong>과 <strong>높이(Height)</strong>를 나타내는 표준 규격인 경우가 대부분입니다.</p> <p>보통 4자리 숫자로 표기되는데, 규칙은 다음과 같습니다.</p> <ul> <li><strong>앞의 두 자리:</strong> 모터 스테이터의 직경 (mm)</li> <li><strong>뒤의 두 자리:</strong> 모터 스테이터의 높이 (mm)</li> </ul> <p>예를 들어, <code class="language-plaintext highlighter-rouge">3305</code> 모터라고 하면 직경이 약 33mm이고 높이가 5mm인 납작한 모터를 의미합니다.</p> <p>이 수치들이 중요한 이유는 <strong>“모터의 외관 치수가 곧 모터의 성능 특성(Torque vs Speed)을 결정짓는 핵심 변수”</strong>이기 때문입니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/pancake-480.webp 480w,/assets/img/hardware/pancake-800.webp 800w,/assets/img/hardware/pancake-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/pancake.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> MIT Mini Cheetah 에 사용된 Outrunner 팬케이크 모터 [3] </div> </div> </div> <h3 id="지름-diameter-토크의-크기">지름 (Diameter): 토크의 크기</h3> <p>모터의 지름은 <strong>토크(Torque)</strong>와 직접적으로 연결됩니다. 물리적으로 토크는 $\tau = F \times r$ (힘 $\times$ 반지름)입니다. 모터 지름이 커진다는 것은 전자기력이 작용하는 회전 반경(Air gap radius)이 커진다는 뜻이므로, 같은 전류를 흘려도 더 큰 토크를 만들어낼 수 있습니다.</p> <p>따라서 <strong>저속·고토크</strong> 구동이 필요한 경우 지름이 큰 모터가 유리합니다. 이 특성을 극대화한 것이 바로 <strong>팬케이크(Pancake) 모터</strong>입니다. 지름은 매우 크고 높이는 얇은 이 모터들은, 축 방향 공간을 절약하면서도 강력한 순간 토크를 낼 수 있어 로봇 다리 관절이나 짐벌 등에 자주 사용됩니다.</p> <h3 id="높이-height-연속-출력과-발열">높이 (Height): 연속 출력과 발열</h3> <p>모터의 높이(길이)는 순간적인 최대 토크보다는 <strong>지속 가능한 출력(Continuous Power)</strong> 및 <strong>발열 특성</strong>과 밀접합니다.</p> <p>모터가 길어지면:</p> <ol> <li><strong>자속 경로 확보:</strong> 마그넷과 코일이 상호작용하는 면적이 넓어져 토크 상수($K_t$)가 커집니다.</li> <li><strong>열 용량 증가:</strong> 모터의 부피와 표면적이 늘어나 열을 저장하고 방출하는 능력이 좋아집니다.</li> </ol> <p>즉, 지름이 같더라도 높이가 높은 모터는 더 오랫동안 높은 전류를 버틸 수 있습니다. 따라서 발열 제어가 중요한 연속 구동 환경이나, 좁고 긴 공간을 활용해야 하는 <strong>리니어 액추에이터</strong> 설계에서는 길이가 긴(Long) 형태의 모터가 선호됩니다.</p> <hr/> <h2 id="bldc-모터의-물리-전압-전류-그리고-역기전력">BLDC 모터의 물리: 전압, 전류, 그리고 역기전력</h2> <p>흔히 “모터를 켠다”고 말하지만, 엔지니어의 관점에서 이는 <strong>자기장의 크기와 방향을 제어한다</strong>는 뜻입니다. 그리고 이 과정에서 <strong>전압(Voltage)</strong>과 <strong>전류(Current)</strong>는 서로 다른 역할을 수행합니다.</p> <h3 id="전류current는-토크torque다">전류(Current)는 토크(Torque)다</h3> <p>BLDC 모터 제어의 제1 원칙입니다. 자기장의 세기를 결정하는 것은 코일에 흐르는 전류량이며, 그 결과로 만들어지는 힘이 토크입니다. 따라서 모터의 토크는 (자기포화가 오기 전까지는) <strong>전류에 거의 정비례</strong>합니다. 로봇 제어기가 “토크 제어”를 수행한다는 것은 결국 “전류 제어”를 한다는 말과 같습니다.</p> <h3 id="전압voltage은-속도speed의-한계다">전압(Voltage)은 속도(Speed)의 한계다</h3> <p>하지만 전류 혼자서는 흐를 수 없습니다. 전류를 밀어주는 압력이 바로 전압입니다.</p> <ul> <li><strong>전류:</strong> 토크의 크기를 결정</li> <li><strong>전압:</strong> 전류를 얼마나 빠르게, 얼마나 많이 밀어 넣을 수 있는지를 결정 (속도 한계)</li> </ul> <h3 id="역기전력-back-emf-속도가-토크를-갉아먹는-이유">역기전력 (Back-EMF): 속도가 토크를 갉아먹는 이유</h3> <p>모터가 회전하면 코일 내부에서는 렌츠의 법칙에 의해 <strong>역기전력(Back-EMF)</strong>이 발생합니다. 이는 내가 인가한 전압에 저항하는 ‘반대 방향의 전압’입니다.</p> <ul> <li><strong>저속 회전 시:</strong> 역기전력이 작아 배터리 전압의 대부분을 전류를 밀어 넣는 데 쓸 수 있습니다. (높은 토크 가능)</li> <li><strong>고속 회전 시:</strong> 역기전력이 커져서 실제 코일에 걸리는 유효 전압(Effective Voltage)이 줄어듭니다.</li> </ul> <p>결국 모터가 일정 속도 이상으로 빨라지면, 전압의 한계(Voltage Ceiling)에 부딪혀 더 이상 전류를 밀어 넣을 수 없게 되고, 토크는 급격히 떨어지게 됩니다.</p> <blockquote> <p><strong>발전기로서의 모터:</strong> 반대로 외력에 의해 모터가 강제로 회전할 때도 Back-EMF가 발생합니다. 이때 모터 단자가 연결되어 있다면(Closed Circuit), 모터는 발전기가 되어 전류를 생성하고 저항감을 만듭니다. 이 원리는 로봇의 <strong>댐핑(Damping)</strong> 제어나 회생 제동에 활용됩니다.</p> </blockquote> <hr/> <h2 id="발열-모터-성능의-진짜-한계">발열: 모터 성능의 진짜 한계</h2> <p>모터 데이터시트에 적힌 ‘최대 토크(Peak Torque)’는 사실 1~2초만 쓸 수 있는 허상에 가깝습니다. 로봇 엔지니어가 봐야 할 진짜 성능 지표는 <strong>발열</strong>에 의해 결정됩니다.</p> <div class="row mt-3"> <div class="col-sm-6 mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/torque_current-480.webp 480w,/assets/img/hardware/torque_current-800.webp 800w,/assets/img/hardware/torque_current-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/torque_current.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> 전류에 의한 열 손실 [4] </div> </div> <div class="col-sm-6 mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/motor_thermal_limit-480.webp 480w,/assets/img/hardware/motor_thermal_limit-800.webp 800w,/assets/img/hardware/motor_thermal_limit-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/motor_thermal_limit.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> 모터의 속도 와 토크 [4] </div> </div> </div> <p>모터가 뜨거워지면 단순히 화상을 입는 문제가 아니라, 물리적 특성이 변해버립니다.</p> <ol> <li><strong>저항 증가:</strong> 구리 코일의 온도가 오르면 저항($R$)이 커져 더 많은 전압이 필요해집니다.</li> <li><strong>자속 감소 (Thermal Demagnetization):</strong> 영구자석은 온도가 오르면 자성이 약해집니다.</li> <li><strong>토크 상수($K_t$) 하락:</strong> 결과적으로 같은 전류를 흘려도 예전만큼의 토크가 나오지 않습니다.</li> </ol> <p>이 현상은 서서히 일어나기 때문에 짧은 실험에서는 간과하기 쉽습니다. 하지만 장시간 구동 시 제어 성능이 틀어지거나 모터가 타버리는 주원인이 됩니다.</p> <p>따라서 로봇 액추에이터 선정 시에는 Stall Torque가 아닌, <strong>연속 토크 (Continuous Torque / Rated Torque)</strong>—즉, 모터가 열평형 상태에서 무한히 버틸 수 있는 토크—를 기준으로 삼아야 합니다.</p> <p><a href="/hardware03-kr/">다음 포스트 : [로봇 하드웨어 03] - 엑추에이터(2): 감속기</a></p> <h3 id="references">References</h3> <p>[1] https://docs.espressif.com/projects/esp-iot-solution/en/release-v2.0/motor/bldc/bldc_overview.html</p> <p>[2] https://www.gian-transmission.com/a-comprehensive-guide-to-brushless-dc-motor/</p> <p>[3] https://www.semanticscholar.org/paper/A-low-cost-modular-actuator-for-dynamic-robots-Katz/80732f8a46655aa4a1037a7fbdc154f4ceb33c50</p> <p>[4] https://things-in-motion.blogspot.com/2019/05/understanding-bldc-pmsm-electric-motors.html</p>]]></content><author><name></name></author><category term="Hardware"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - BLDC 모터]]></summary></entry><entry xml:lang="en"><title type="html">[Robot Hardware 01] - What is Robot Hardware?</title><link href="https://dokkev.github.io/hardware01/" rel="alternate" type="text/html" title="[Robot Hardware 01] - What is Robot Hardware?"/><published>2025-12-01T00:00:00+00:00</published><updated>2025-12-01T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-01</id><content type="html" xml:base="https://dokkev.github.io/hardware01/"><![CDATA[<h2 id="what-is-robot-hardware">What is Robot Hardware?</h2> <p>When people hear “robot hardware,” they often first think of visible components like motors or structural frames. In a dictionary sense, hardware simply refers to the physical constituents of a system. But in the context of multi-jointed robots, “hardware” encompasses much more than that. It goes beyond drive mechanisms, sensors, and control PCs to include <strong>embedded systems</strong> that control motors at high frequencies (high-bandwidth), <strong>network configurations</strong> for communication with the control PC, <strong>physics model-based control</strong> such as gravity compensation, and even <strong>CoM (Center of Mass) control</strong> for floating base control or <strong>optimal control-based controllers</strong> for basic stability. In many cases within the robotics field, these elements are collectively referred to as the “hardware level.”</p> <p>Strictly speaking, these elements belong to the software domain. But here’s the thing—without these foundations, a robot can’t even reach a state where experiments or data collection are possible. So viewing robot hardware simply as “a machine with many motors” means you’re missing a crucial piece of the puzzle.</p> <p>From the perspective of <strong>Physical AI</strong>, which is a major topic of discussion today, a robot isn’t just a machine executing commands—it’s an <strong>intelligent system that interacts directly with the physical world.</strong> A robot transmits force, the environment changes in reaction to that force, and the robot perceives those changes back through its sensors. Hardware is always at the center of this loop.</p> <p>While various multi-jointed robots may look similar in their structural appearance, the way they actually interact with their environment differs significantly depending on their hardware. Even with identical joint structures, the type, material, and ratio of the gearboxes change the <strong>output impedance</strong> and <strong>backdrivability</strong>. This directly dictates how rigidly or softly the robot responds at the moment of contact. When you add the robot’s overall mass distribution and inertia into the mix, the actual force and acceleration delivered can vary wildly, even with the same control input. This becomes especially apparent in tasks involving repetitive contact, such as <strong>manipulation</strong> or <strong>locomotion</strong>—these differences lead directly to variations in stability and success rates.</p> <p>The same applies to sensors and control. Control loops, communication latency, noise, sensor sensitivity, linearity, and hysteresis characteristics all play vital roles. When combined with structural stiffness, joint compliance, and friction, the interaction produced by a robot becomes the result of numerous coupled classical mechanical and electromagnetic properties.</p> <h2 id="ai-and-robot-hardware">AI and Robot Hardware</h2> <p>Because of these diverse hardware factors, there are inherent limits to fully replicating robot interactions in simulation. Small variables like friction, structural flexibility, sensor non-linearity, and communication delays often play dominant roles in real-world interactions. For this reason, AI-based approaches—specifically <strong>Reinforcement Learning (RL)</strong> for control and policy learning—often face challenges where models trained in simulation fail to perform on real robots. This is commonly known as the <strong>“sim-to-real gap.”</strong></p> <p>The forces and reactions a robot exchanges with its environment are ultimately determined by the physical characteristics defined by the hardware. But here’s a bigger issue: these physical characteristics vary from robot to robot. Data collected or controllers trained on one robot often fail to achieve the same performance on another. As a result, collecting data with physical robots is difficult, and sharing or reusing data across different platforms is even more complex.</p> <p>From this viewpoint, the limitations of AI-based robot control often stem from the physical conditions dictated by the hardware rather than the algorithms themselves. Without understanding the hardware, it’s difficult to explain why an AI fails or to define the boundaries of what it can achieve.</p> <h2 id="understanding-robot-hardware">Understanding Robot Hardware</h2> <p>In this blog, I intend to discuss robot hardware by breaking it down into several layers. From the visible mechanical structures and actuators to the drive mechanisms and sensors that make them move, and finally to low-level and physics model-based control—we’ll step through the hardware elements required for a multi-jointed robot to function.</p> <p>I plan to explore the role of each layer, where limitations arise, and how those limits affect real-world robot performance and AI-based control. My goal is to organize these thoughts not just from the perspective of a user, but from the viewpoint of someone who must <strong>directly handle, repair, and design</strong> these systems.</p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[Robot hardware from a Physical AI perspective - Introduction]]></summary></entry><entry xml:lang="ko"><title type="html">[로봇 하드웨어 01] - 로봇 하드웨어란?</title><link href="https://dokkev.github.io/hardware01-kr/" rel="alternate" type="text/html" title="[로봇 하드웨어 01] - 로봇 하드웨어란?"/><published>2025-12-01T00:00:00+00:00</published><updated>2025-12-01T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-01-kr</id><content type="html" xml:base="https://dokkev.github.io/hardware01-kr/"><![CDATA[<h2 id="로봇-하드웨어란-무엇일까">로봇 하드웨어란 무엇일까?</h2> <p>로봇 하드웨어라고 하면 보통 모터나 프레임 같은 눈에 보이는 부품을 먼저 떠올리게 됩니다. 사전적인 의미로만 보면 하드웨어는 단순히 물리적인 구성 요소를 뜻합니다.</p> <p>하지만 다관절 로봇에서 말하는 하드웨어는 구동 메커니즘, 센서, 제어용 PC를 넘어 모터를 높은 주기(High-Frequency)로 제어하는 <strong>임베디드 시스템</strong>, 제어 PC와의 통신을 위한 <strong>네트워크 구성</strong>, 중력 보상 같은 <strong>물리 모델 기반 제어</strong>, 그리고 보행 로봇의 Floating Base <strong>CoM(Center of Mass) 제어</strong>나 기본적인 안정성을 확보하기 위한 <strong>최적 제어 계열의 제어기</strong>까지도 포함합니다. 로봇 공학에서는 이 모든 것을 “하드웨어 레벨”로 묶어서 이야기하는 경우가 많습니다.</p> <p>엄밀히 말하면 이러한 요소들은 소프트웨어에 속하지만, 이것들이 제대로 갖춰져 있지 않으면 로봇은 실험이나 데이터 수집이 가능한 상태에조차 도달하지 못하기 때문입니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/hardware-480.webp 480w,/assets/img/hardware/hardware-800.webp 800w,/assets/img/hardware/hardware-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/hardware.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> 로봇 하드웨어의 구성 요소들 [1] </div> </div> </div> <p>그래서 로봇 하드웨어를 단순히 “모터가 많이 달린 기계” 정도로 생각하면 중요한 부분을 놓치게 됩니다. 요즘 화두가 되는 <strong>Physical AI</strong> 관점에서 보면, 로봇은 단순히 명령을 실행하는 기계가 아니라 <strong>물리 세계와 직접 상호작용하는 지능형 시스템</strong>에 가깝습니다. 로봇은 직접 힘을 전달하고, 그 힘에 대한 반작용으로 환경이 변하며, 그 변화를 다시 센서를 통해 감지합니다. 이 상호작용의 중심에는 항상 하드웨어가 있습니다.</p> <p>다양한 다관절 로봇들이 외관상으로는 비슷해 보여도, 실제로 환경과 상호작용하는 방식은 하드웨어마다 크게 다릅니다. 같은 관절 구조처럼 보여도 감속기의 종류와 재질, 감속비에 따라 <strong>역구동성(Backdrivability)</strong>, 즉 외부 힘에 순응하는 <strong>기계적 임피던스(Mechanical Impedance)</strong> 이 달라지며, 이는 접촉 순간 로봇이 얼마나 단단하게 혹은 부드럽게 반응하는지를 결정합니다.</p> <p>여기에 로봇 전체의 질량 분포와 관성이 더해지면, 동일한 제어 입력이라도 실제로 전달되는 힘과 가속도는 완전히 달라집니다. 특히 조작(Manipulation)이나 보행(Locomotion)처럼 반복적인 접촉이 포함된 작업에서는 이러한 차이가 시스템의 안정성이나 작업 성공률로 직결됩니다.</p> <p>센서와 제어 측면도 마찬가지입니다. 제어 주기, 통신 지연과 노이즈, 센서의 감도와 선형성, 히스테리시스(Hysteresis) 특성 등은 제어 성능에 지대한 영향을 미칩니다. 여기에 구조 강성, 관절 강성, 마찰 같은 요소까지 더해지면, 로봇이 만들어내는 상호작용은 수많은 고전역학적·전자기학적 특성들이 결합된 정교한 결과물이 됩니다.</p> <h2 id="ai와-로봇-하드웨어">AI와 로봇 하드웨어</h2> <p>로봇 하드웨어의 복잡성은 단순히 기계적인 문제를 넘어, 최신 AI 알고리즘의 적용을 가로막는 본질적인 장벽으로 작용합니다. 이 장벽은 크게 <strong>‘Sim-to-Real Gap’</strong>와 <strong>‘Embodiment Gap’</strong>라는 두 가지 형태로 나타납니다.</p> <p>첫 번째는 <strong>“Sim-to-Real Gap”</strong>입니다. 주로 보행 로봇이나 드론 제어에 많이 쓰이는 강화학습(Reinforcement Learning) 분야에서 두드러지는 문제입니다. 시뮬레이션은 마찰, 기어의 백래시(Backlash), 구조적 유연성, 통신 지연 같은 미세한 물리적 특성을 완벽히 재현하지 못합니다. AI 모델이 시뮬레이션 속 이상적인 물리 법칙에 과적합(Overfitting)되면, 실제 로봇에서는 작은 마찰이나 진동에도 제어기가 발산하거나 엉뚱하게 동작하기 일쑤입니다. 로봇이 환경과 주고받는 힘과 반응은 결국 시뮬레이터가 아닌, 실제 하드웨어가 규정하는 물리적 특성 위에서 결정되기 때문입니다.</p> <p>두 번째는 <strong>“Embodiment Gap”</strong>입니다. 이는 대량의 데이터를 수집하여 제어 정책(Policy)을 학습하는 최근의 데이터 기반 접근법(Data-Driven Approach), 즉 VLA 모델이나 모방 학습 등의 범용적 확장을 가로막는 주원인입니다.</p> <p>단순한 링크 길이나 자유도 같은 기구학적 차이는 리타게팅(Retargeting) 기술로 보정이 가능합니다. 그러나 본질적인 문제는 <strong>로봇마다 고유한 동역학적 특성과 힘의 상관관계</strong>가 다르다는 점에 있습니다. 동일한 궤적을 추종하더라도, 관절의 마찰, 액추에이터의 관성, 감속기의 백래시, 그리고 제어 대역폭에 따라 로봇이 환경에 가하는 힘과 그에 따른 반작용은 완전히 달라집니다.</p> <p>예를 들어, 토크 제어 기반의 유연한(Compliant) 로봇에서 수집한 데이터는 위치 제어 기반의 단단한(Stiff) 로봇에 그대로 적용하기 어렵습니다. 수집된 데이터에 내재된 ‘입력-출력’의 매핑 관계가 하드웨어의 임피던스 특성에 따라 상이하기 때문입니다. 결국 하드웨어 플랫폼이 달라지면 로봇이 환경과 상호작용하는 물리적 법칙 자체가 달라지므로, 기껏 수집한 데이터와 학습된 정책의 상호 운용이나 전이(Transfer)가 불가능해지는 것입니다.</p> <p>결국 AI 기반 로봇 제어의 한계는 알고리즘 그 자체보다, 하드웨어가 규정하는 물리적 조건에서 비롯되는 경우가 많습니다. 하드웨어를 깊이 이해하지 않고서는 Sim-to-Real Gap을 넘어설 수 없고, Embodiment Gap을 극복할 범용적인 데이터셋을 구축하기도 어렵습니다.</p> <h2 id="로봇-하드웨어의-이해">로봇 하드웨어의 이해</h2> <p>앞으로 이 블로그에서는 로봇 하드웨어를 여러 계층으로 나누어 다루어 보려고 합니다. 눈에 보이는 기계 구조와 액추에이터부터, 이를 실제로 움직이게 만드는 구동 메커니즘과 센서, 그리고 하위 레벨(Low-level) 제어와 물리 모델 기반 제어까지 다관절 로봇이 동작하기 위해 필요한 하드웨어 요소들을 단계별로 살펴볼 계획입니다.</p> <p>각 계층이 어떤 역할을 하고, 어디에서 한계가 발생하며, 그 한계가 실제 로봇의 성능이나 AI 기반 제어에 어떤 영향을 주는지 함께 짚어보겠습니다. 로봇을 단순히 사용하는 입장이 아니라, <strong>직접 설계하고 제어하며 문제를 해결해야 하는 관점</strong>에서 내용을 정리해보는 것이 목표입니다.</p> <p><a href="/hardware02-kr/">다음 포스트 : [로봇 하드웨어 02] - 엑추에이터(1): 모터</a></p> <h2 id="references">References</h2> <p>[1] https://www.ros.org/news/2016/10/hardware-robot-operating-system-h-ros.html</p>]]></content><author><name></name></author><category term="Hardware"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - 서론]]></summary></entry><entry><title type="html">[CAN 05] - PCAN Device Driver Installation on Linux</title><link href="https://dokkev.github.io/pcan/" rel="alternate" type="text/html" title="[CAN 05] - PCAN Device Driver Installation on Linux"/><published>2024-10-14T00:00:00+00:00</published><updated>2024-10-14T00:00:00+00:00</updated><id>https://dokkev.github.io/pcan</id><content type="html" xml:base="https://dokkev.github.io/pcan/"><![CDATA[<p>PEAK-System’s PCAN hardware is a staple in robotics and industrial automation. On Linux, developers generally have two interface options: the native <strong>SocketCAN (NetDev)</strong> and the proprietary <strong>PCAN Driver (CharDev)</strong>.</p> <p>While SocketCAN offers great “plug-and-play” convenience, many advanced robotics projects require the specific capabilities of the <strong>Character Device (CharDev)</strong> driver.</p> <h3 id="why-professional-developers-choose-chardev">Why Professional Developers Choose CharDev</h3> <ul> <li><strong>PCAN-Basic API Compatibility:</strong> It is the <em>only</em> way to use the <strong>PCAN-Basic API</strong> on Linux. This allows for seamless code portability between Windows and Linux, preserving your existing development workflow.</li> <li><strong>Deterministic Hardware Access:</strong> By bypassing the Linux network stack, CharDev offers a direct path to the hardware. This minimizes jitter and overhead, which is critical for <strong>high-frequency control loops (1 kHz+)</strong> where timing consistency is paramount.</li> <li><strong>Persistent Device Addressing:</strong> Unlike network interfaces (<code class="language-plaintext highlighter-rouge">can0</code>, <code class="language-plaintext highlighter-rouge">can1</code>) that can reorder on reboot, CharDev allows you to reliably identify hardware using persistent <strong>Device IDs</strong>, simplifying the management of multi-axis robotic systems.</li> </ul> <p>In this guide, we will walk through the compilation and installation of the PEAK-System proprietary driver and the PCAN-Basic API on Linux.</p> <h2 id="part-1-installing-the-pcan-linux-driver">Part 1: Installing the PCAN Linux Driver</h2> <p>First, we need to install the core driver. You can find the latest proprietary <a href="https://www.peak-system.com/fileadmin/media/linux/index.php#Section_Driver-Proproetary">PCAN-Linux driver package here</a>. For deeper technical details, you can always refer to the official <a href="https://www.peak-system.com/fileadmin/media/linux/files/PCAN-Driver-Linux_UserMan_eng.pdf">PCAN Driver Manual</a>.</p> <h3 id="step-1-download-and-extract">Step 1: Download and Extract</h3> <p>Once you’ve downloaded the driver package, open your terminal and extract the files:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-xzvf</span> peak-linux-driver-<span class="k">*</span>.tar.gz
</code></pre></div></div> <p>Navigate into the newly created directory and clear out any old build files:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>peak-linux-driver-<span class="k">*</span>
make clean
</code></pre></div></div> <h3 id="step-2-install-dependencies">Step 2: Install Dependencies</h3> <p>Before we can compile the driver, our system needs a few development libraries. Install them using <code class="language-plaintext highlighter-rouge">apt</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get <span class="nb">install </span>libelf-dev libpopt-dev
</code></pre></div></div> <h3 id="step-3-compile-and-install">Step 3: Compile and Install</h3> <p>Now you are ready to build the driver. Run the following commands:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
make
<span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div> <blockquote> <p><strong>🛠️ Troubleshooting: GCC Errors</strong> If you encounter compilation errors and are using <code class="language-plaintext highlighter-rouge">gcc-11</code>, try compiling with <code class="language-plaintext highlighter-rouge">gcc-12</code> instead. You can do this by specifying the compiler in your make command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
make <span class="nv">CC</span><span class="o">=</span>gcc-12
<span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div> </div> </blockquote> <h3 id="a-note-on-socketcan-vs-pcan-basic">A Note on SocketCAN vs. PCAN-Basic</h3> <p>By default, running the standard <code class="language-plaintext highlighter-rouge">make</code> command builds the driver with <strong><code class="language-plaintext highlighter-rouge">chardev</code></strong> (Character Device) support. This is exactly what you need if you plan to use the PCAN-Basic API.</p> <p>However, if your goal is to use the device with <strong>SocketCAN</strong> (which typically works without driver installation on modern kernels, but might need an update on older ones), you must explicitly rebuild the driver with network device support (<code class="language-plaintext highlighter-rouge">netdev</code>):</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-C</span> driver <span class="nv">NET</span><span class="o">=</span>NETDEV_SUPPORT
</code></pre></div></div> <hr/> <h2 id="part-2-installing-the-pcan-basic-api">Part 2: Installing the PCAN-Basic API</h2> <p>With the base driver installed via <code class="language-plaintext highlighter-rouge">chardev</code>, we can now install the PCAN-Basic API. This API provides the necessary libraries to write custom applications (in C++, Python, etc.) that communicate with your CAN bus.</p> <h3 id="step-1-download-and-extract-1">Step 1: Download and Extract</h3> <p>Head over to the PEAK-System website and <a href="https://www.peak-system.com/PCAN-Basic.239.0.html?&amp;L=1">Download the PCAN-Basic API for Linux</a>.</p> <p>Extract the tarball and navigate into the <code class="language-plaintext highlighter-rouge">pcanbasic</code> source directory:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-xzvf</span> PCAN-Basic_Linux-<span class="k">*</span>.tar.gz
<span class="nb">cd </span>PCAN-Basic_Linux-<span class="k">*</span>/libpcanbasic/pcanbasic/
</code></pre></div></div> <h3 id="step-2-compile-and-install">Step 2: Compile and Install</h3> <p>Just like with the driver, we will clean, make, and install the API libraries:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
make
<span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div> <hr/> <h2 id="part-3-load-the-driver">Part 3: Load the Driver</h2> <p>Normally, installing kernel modules requires a system reboot. However, you can bypass this and start using your CAN interface immediately by asking the Linux kernel to probe for the newly installed PCAN module:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>modprobe pcan
</code></pre></div></div> <p>Plug in your PCAN hardware, and you are ready to start sniffing, sending, and analyzing CAN frames!</p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[Step-by-step guide to installing PEAK-System's PCAN drivers on Linux for SocketCAN and PCAN-Basic API]]></summary></entry><entry><title type="html">Resources for Learning Robotics</title><link href="https://dokkev.github.io/Intro-to-Robotics/" rel="alternate" type="text/html" title="Resources for Learning Robotics"/><published>2024-04-12T00:00:00+00:00</published><updated>2024-04-12T00:00:00+00:00</updated><id>https://dokkev.github.io/Intro-to-Robotics</id><content type="html" xml:base="https://dokkev.github.io/Intro-to-Robotics/"><![CDATA[<p>Robotics research requires multidisciplinary knowledge in mathematics, mechanical engineering, electrical engineering, computer engineering, and computer science. This post provides a collection of resources for learning robotics for beginners.</p> <h2 id="fundamental-robotics-knowledge">Fundamental Robotics Knowledge</h2> <p>Short videos that explain the basic concepts of robotics.</p> <h3 id="robot-configuration">Robot Configuration</h3> <ul> <li><a href="https://www.youtube.com/watch?v=zjMuIxRvygQ&amp;t=33s">Quaternions and Rotation in 3D Space, explained interactively</a></li> <li><a href="https://www.youtube.com/watch?v=d4EgbgTm0Bg&amp;t=469s">Visualizing quaternions (4d numbers) with stereographic projection</a></li> <li><a href="https://www.youtube.com/watch?v=zc8b2Jo7mno">Explaining Gibmal Lock</a></li> <li><a href="https://www.youtube.com/watch?v=FyLNR3edOds&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=6">Configuration Space</a></li> <li><a href="https://www.youtube.com/watch?v=hTuW51CpUg4&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=9">Task Space and Workspace</a></li> <li><a href="https://www.youtube.com/watch?v=mvGZtO_ruj0&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=17">Twist</a></li> <li><a href="https://www.youtube.com/watch?v=0wsYPJPGtKE&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=20">Wrenches</a></li> </ul> <h3 id="coordinate-transformation">Coordinate Transformation</h3> <ul> <li><a href="https://www.youtube.com/watch?v=lVjFhNv2N8o">Robotics 1 U1 (Kinematics) S3 (Rotation Matrices) P1 (Rotation Matrices)</a></li> <li><a href="https://www.youtube.com/watch?v=H_94DTWd8ck">2D Coordinate Transformation</a></li> <li><a href="https://www.youtube.com/watch?v=rHLEWRxRGiM">3D Coordinate Transformation</a></li> </ul> <h3 id="robot-kinematics">Robot Kinematics</h3> <ul> <li><a href="https://www.youtube.com/watch?v=bohL918kXQk">Jacobian Matrix</a></li> <li><a href="https://www.youtube.com/watch?v=hhFzJvaY__U&amp;t=510s">Change of Variables and the Jacobian</a></li> <li><a href="https://www.youtube.com/watch?v=vCEWORZbD3Y&amp;t=55s">Robot Singularities</a></li> <li><a href="https://www.youtube.com/watch?v=vjJgTvnQpBs&amp;t=93s">Singularities</a></li> <li><a href="https://www.youtube.com/watch?v=wgpgNLEEpeY">2D Inverse Kinematics with Graphic Visualization</a></li> <li><a href="https://www.youtube.com/watch?v=VhUA0jf7tI8">Numerical Inverse Kinematics (1)</a></li> <li><a href="https://www.youtube.com/watch?v=24cXvgQl-nk">Numerical Inverse Kinematics (2)</a></li> <li><a href="https://www.youtube.com/watch?v=eQ9E0Zvp9jw&amp;t=198s">Odometery</a></li> </ul> <h3 id="robot-dynamics-and-control">Robot Dynamics and Control</h3> <ul> <li><a href="https://ethz.ch/content/dam/ethz/special-interest/mavt/robotics-n-intelligent-systems/rsl-dam/documents/RobotDynamics2017/RD_HS2017script.pdf">ETH Zurich Robot Dynamics Lecture Notes</a></li> <li><a href="https://www.youtube.com/watch?v=8UtnDaGHpq0">Introduction to Lagrangian Mechanics</a></li> <li><a href="http://www.aoengr.com/Dynamics/LagrangianMechanicsPendulum.pdf">Simple Pendulum via Lagrangian Mechanics</a></li> <li><a href="https://www.youtube.com/watch?v=1U6y_68CjeY">Lagrangian Formulation of Robot Dynamics</a></li> <li><a href="https://www.youtube.com/watch?v=ZASVKAlegfQ">Inverse Dynamics</a></li> <li><a href="https://www.youtube.com/watch?v=5A39Ht9Wcu0">Largangian Multipliers</a></li> <li><a href="https://www.youtube.com/watch?v=keMzpa_iWjs">Constrained Lagrangian Mechanics</a></li> <li><a href="https://www.youtube.com/watch?v=_bWvXn4ilrY">PID Control Explained with Robotics</a></li> <li><a href="https://www.youtube.com/watch?v=IolG5V_skv8">Imedpance and Admittance Control</a></li> <li><a href="https://www.youtube.com/watch?v=iQa01aFgf8U">Task Space Dynamics</a></li> <li><a href="https://www.youtube.com/watch?v=GMnO6qntsYc">Redundant Manipulator Control with Nullspace Projection</a></li> <li><a href="https://www.youtube.com/watch?v=UR0GpaaBVKk">Hybrid Position/Force Control</a></li> <li><a href="https://www.youtube.com/watch?v=YwodGM2eoy4">Model Predictive Control</a></li> <li><a href="https://www.youtube.com/watch?v=-FvrON0OmYc">Anatomy of a Dynamical System</a></li> </ul> <h3 id="motion-planning">Motion Planning</h3> <ul> <li><a href="https://www.youtube.com/watch?v=Ob3BIJkQJEw">RRT</a></li> <li><a href="https://www.youtube.com/watch?v=s2qrMwqm4D0&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=51">Motion Planning in C-Space</a></li> <li><a href="https://msl.cs.illinois.edu/~lavalle/papers/Lav11b.pdf">Motion Planning Tutorial</a></li> </ul> <h3 id="robot-electronics-and-embedded-system">Robot Electronics and Embedded System</h3> <ul> <li><a href="https://www.youtube.com/watch?v=bCEiOnuODac">BLDC Motors</a></li> <li><a href="https://www.youtube.com/watch?v=KmnztbTCvxM">DC Motor Speed-Torque Plane</a></li> <li><a href="https://www.youtube.com/watch?v=pxtRlKs0pAg">DC Motor Speed-Torque Curve</a></li> <li><a href="https://www.youtube.com/watch?v=YPD1_rcXBIE">Field Oriented Control</a></li> <li><a href="https://www.youtube.com/watch?v=JgnPSOUoVJI">Back EMF</a></li> <li><a href="https://www.youtube.com/watch?v=k2GQVJ4z0kM">Encoder</a></li> <li><a href="https://www.youtube.com/watch?v=IyGwvGzrqp8">Serial Communication</a></li> <li><a href="https://www.youtube.com/watch?v=WikQ5n1QXQs">Control Area Network (CAN)</a></li> <li><a href="https://www.youtube.com/watch?v=tYAl2jkaB8Q">EtherCAT</a></li> </ul> <h3 id="robot-mechanism">Robot Mechanism</h3> <ul> <li><a href="https://www.youtube.com/watch?v=VvYSrsqALKc">Reflection of a Motor</a></li> <li><a href="https://www.youtube.com/watch?v=zI64DyaRUvQ">Degrees of Freedom of a Robot</a></li> <li><a href="https://underactuated.mit.edu/intro.html">Underactuated Systems</a></li> <li><a href="https://www.youtube.com/watch?v=8q25EUszBSI">Bearing</a></li> <li><a href="https://www.youtube.com/watch?v=ZhDO16FDmxA&amp;t=55s">Gears</a></li> <li><a href="https://khkgears.net/new/gear_knowledge/gear_technical_reference/gear_backlash.html">Backlash</a></li> <li><a href="https://www.youtube.com/watch?v=TzJkD87eQNI">Planetary Gears</a></li> <li><a href="https://www.youtube.com/watch?v=C_khtPviVPg">Timing Belts and Pulleys</a></li> <li><a href="https://www.youtube.com/watch?v=uJiauHFUbn8">Cable-Driven Transmission</a></li> <li><a href="https://www.youtube.com/watch?v=gZLO2Am0Zk8">Series Elastic Actuators</a></li> <li><a href="https://www.youtube.com/watch?v=Mhxz2Bj2RXA">MIT Mini Cheetah Actuator Teardown</a></li> <li><a href="https://www.youtube.com/watch?v=VZKsla53FAw">Stiffness and Damping Identification</a></li> <li><a href="https://www.youtube.com/watch?v=TQiLLcumqDw">Rolling Contact Joint</a></li> </ul> <h3 id="machine-learning">Machine Learning</h3> <ul> <li><a href="https://www.youtube.com/watch?v=yMgFHbjbAW8">Residual and Least Squares Regression</a></li> <li><a href="https://www.youtube.com/watch?v=aircAruvnKk&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi">Neural Network</a></li> <li><a href="https://www.youtube.com/watch?v=EKbFIWANwHw">Gradient Descent</a></li> <li><a href="https://www.youtube.com/watch?v=IHZwWFHWa-w&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&amp;index=2">Graident Descent in Deep Learning</a></li> <li><a href="https://www.youtube.com/watch?v=oJNHXPs0XDk">Neural Network Architectures</a></li> <li><a href="https://www.youtube.com/watch?v=Ilg3gGewQ5U&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&amp;index=3">Backpropagation</a></li> <li><a href="https://www.youtube.com/watch?v=wjZofJX0v4M&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&amp;index=5">Transformer (1)</a></li> <li><a href="https://www.youtube.com/watch?v=eMlx5fFNoYc&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&amp;index=6">Transformer (2)</a></li> </ul> <h3 id="locomotion">Locomotion</h3> <ul> <li><a href="https://www.youtube.com/watch?v=Pt_ikHJnNs4">Zero Moment Point</a></li> </ul> <hr/> <h2 id="robot-operating-system-ros">Robot Operating System (ROS)</h2> <ul> <li><a href="https://docs.ros.org/en/iron/index.html">ROS 2 Documentation</a></li> <li><a href="https://docs.ros.org/en/iron/Tutorials.html">Official ROS 2 Tutorials</a></li> <li><a href="https://articulatedrobotics.xyz/page4/">ROS 2 Tutorials</a> by <a href="https://www.youtube.com/@ArticulatedRobotics">Articulated Robotics</a></li> <li><a href="https://industrial-training-master.readthedocs.io/en/melodic/_source/session3/Intro-to-URDF.html">URDF</a></li> </ul> <hr/> <p>Online Courses</p> <p>Online lecture series and courses on robotics.</p> <h2 id="mathematics">Mathematics</h2> <h3 id="linear-algebra">Linear Algebra</h3> <ul> <li><a href="https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/">Linear Algebra</a> by Gilbert Strang at MIT</li> <li><a href="https://www.3blue1brown.com/topics/linear-algebra">Essence of Linear Algebra</a> by Grant Sanderson (<a href="https://www.youtube.com/@3blue1brown">3Blue1Brown</a>)</li> <li><a href="https://www.khanacademy.org/math/linear-algebra">Linear Algebra</a> by Khan Academy</li> </ul> <h3 id="differential-equation">Differential Equation</h3> <ul> <li><a href="https://www.khanacademy.org/math/differential-equations">Differential Equation</a>by Khan Academy</li> </ul> <h3 id="probability">Probability</h3> <ul> <li><a href="https://www.youtube.com/playlist?list=PL2SOU6wwxB0uwwH80KTQ6ht66KWxbzTIo">Statistics 110: Probability</a> by Joe Blitzstein at Harvard University</li> </ul> <hr/> <h2 id="robot-mechanics-design-and-control">Robot Mechanics, Design, and Control</h2> <h3 id="robotic-manipulation">Robotic Manipulation</h3> <ul> <li><a href="https://modernrobotics.northwestern.edu/nu-gm-book-resource/foundations-of-robot-motion/">Modern Robotics</a> by Kevin Lynch at Northwestern University</li> <li><a href="https://manipulation.csail.mit.edu/index.html">Robotic Manipulation</a> by Russ Tedrake at MIT</li> </ul> <h3 id="robot-mechanism-design">Robot Mechanism Design</h3> <ul> <li><a href="https://www.youtube.com/@StanfordCS235/videos">Applied Robot Design</a>by Reuben Brewer at Stanford University</li> </ul> <h3 id="robot-control">Robot Control</h3> <ul> <li><a href="https://underactuated.mit.edu/index.html">Underacutated Robotics</a> by Russ Tedrake at MIT</li> <li><a href="https://web.stanford.edu/class/ee364a/">Convex Optimization</a> by Stephen Boyd at Stanford University</li> <li><a href="https://www.youtube.com/watch?v=Kj88Nory8ec&amp;list=PLZnJoM76RM6Jv4f7E7RnzW4rijTUTPI4u">Optimal Control</a> by Zachery Manchester at CMU</li> <li><a href="https://www.youtube.com/watch?v=Pi7l8mMjYVE&amp;list=PLMrJAkhIeNNR20Mz-VpzgfQs5zrYi085m">Control Bootcamp</a> by Steven Brunton at University of Washington</li> </ul> <p>https://people.eecs.berkeley.edu/~pabbeel/cs287-fa19/</p> <h2 id="robot-perception-and-navigation">Robot Perception and Navigation</h2> <h3 id="computer-vision">Computer Vision</h3> <ul> <li><a href="https://www.youtube.com/playlist?list=PLzWRmD0Vi2KVsrCqA4VnztE4t71KnTnP5">Modern Computer Vision</a> at UC Berkeley <h3 id="slam">SLAM</h3> </li> <li><a href="https://www.youtube.com/watch?v=U6vr3iNrwRA&amp;list=PLgnQpQtFTOGQrZ4O5QzbIHgl3b1JHimN_&amp;index=1">Robot Mapping</a> by Cyrill Stachniss at University of Bonn</li> </ul> <h2 id="embedded-system">Embedded System</h2> <ul> <li><a href="https://users.ece.utexas.edu/~valvano/Volume1/">Intro to Embedded Systems</a> by Jonathan Valvano at UT Austin <ul> <li><a href="https://www.edx.org/learn/embedded-systems/the-university-of-texas-at-austin-embedded-systems-shape-the-world-microcontroller-input-output">edX</a></li> </ul> </li> </ul>]]></content><author><name></name></author><category term="robotics"/><summary type="html"><![CDATA[Collection of useful resources for learning robotics.]]></summary></entry><entry><title type="html">[CAN 04] - Gripper Motor Control with CAN Bus</title><link href="https://dokkev.github.io/motorcan/" rel="alternate" type="text/html" title="[CAN 04] - Gripper Motor Control with CAN Bus"/><published>2023-12-05T00:00:00+00:00</published><updated>2023-12-05T00:00:00+00:00</updated><id>https://dokkev.github.io/motorcan</id><content type="html" xml:base="https://dokkev.github.io/motorcan/"><![CDATA[<p><strong>Code: [<a href="https://github.com/dokkev/MotorControl-CAN/blob/main/can_motor_control/can_motor_control.ino">GitHub</a>]</strong></p> <p>Previous Posts:</p> <ul> <li><a href="/aboutcan/">What is CAN?</a></li> <li><a href="/socketcan/">Setting up SocketCAN on Linux</a></li> <li><a href="/esp32can/">SocketCAN Communication with ESP32</a></li> </ul> <p><a href="http://www.youtube.com/watch?v=MmSt8G7N8ik"><img src="http://img.youtube.com/vi/MmSt8G7N8ik/0.jpg" alt="Video"/></a></p> <div class="caption"> Optimo Manipulator Pusing and Grabbing a Jenga Block </div> <p>In the previous posts, we have achieved communicating setting up SocketCAN on Ubuntu and communicating with ESP32. In this post, we will control 1-DOF roboric girpper with ESP32 and SocketCAN using <a href="https://simplefoc.com/">SimpleFOC</a> Arduino library.</p> <p>This is a collaborative work <a href="https://roboligent.com/">Roboligent</a> with their robot manipulator, Optimo.</p> <h2 id="hardware">Hardware</h2> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/optimo-480.webp 480w,/assets/img/can/optimo-800.webp 800w,/assets/img/can/optimo-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/optimo.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="optimo" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/gripper-480.webp 480w,/assets/img/can/gripper-800.webp 800w,/assets/img/can/gripper-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/gripper.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="gripper" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Left: Optimo Arm Right: 1-DOF Robotic Gripper </div> <ul> <li><a href="https://docs.simplefoc.com/simplefocmini">SimpleFOC Mini</a></li> <li><a href="https://www.aliexpress.com/i/2251832870920974.html?gatewayAdapt=4itemAdapt">HT2205 with AS5048A Encoder</a> Onlly used for testing not for the gripper</li> <li><a href="https://www.amazon.com/Comimark-Transceiver-TJA1050-Controller-Schnittstelle/dp/B07W4VZ2F2">TJA1050 CAN Transceiver</a></li> <li><a href="https://a.co/d/8sRDkUT">ESP32 Dev Board</a></li> <li><a href="https://makerbase3d.com/product/makerbase-canable-v2/?srsltid=AfmBOoo8SgfMBKoPkINomkXkyG8g6XlvwngQso5DAq0qLKPFEoTqkcba">Makerbase CANable 2.0 USB to CAN adapter</a></li> </ul> <h2 id="wiring">Wiring</h2> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/motor_wire-480.webp 480w,/assets/img/can/motor_wire-800.webp 800w,/assets/img/can/motor_wire-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/motor_wire.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="motor-wiring" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Wiring Diagram for Motor Control </div> <ul> <li> <p>The wiring for ESP32 and CAN Transceiver is same as the <a href="/esp32can/">previous post</a>. Some TJA1050 CAN Transceiver modules and USB-CAN deviuces include internal 120 ohm termination resistor. If you are unsure, measure the resistance between CAN-H and CAN-L wires to ensure it’s reading 60 ohm.</p> </li> <li> <p>Connect the BLDC motor’s u, v, w phases to the SimpleFOC Mini boards’ M1, M2, and M3 pins. The phase order does matter. If they are in a wrong order, the motor will not commmutate properly or run in the opposite direction. SimpleFOC Mini board will need a separate power supply. I will be providing 12 V to control HT2205 motor.</p> </li> <li> <p>Connect IN1, IN2, IN3, and EN pins to ESP32 GPIO pins while GND connects to the ground of ESP32.</p> </li> <li> <p>Supply 5V to SPI encoder and connect the SPI pins to ESP32. Most ESP32 have pre-assigned default SPI pins, but these pin assignment can be different depending on the board. You can check the default SPI pinout of your ESP32 board from the following code:</p> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void setup() {
  
  Serial.begin(115200);
  Serial.print("MOSI: ");
  Serial.println(MOSI);
  Serial.print("MISO: ");
  Serial.println(MISO);
  Serial.print("SCK: ");
  Serial.println(SCK);
  Serial.print("SS: ");
  Serial.println(SS);  
}

void loop() {
}
</code></pre></div></div> <ul> <li> <p>Make sure that there is a proper airgap between the motor magnet and the encoder if you are using magnetic encoder. The recommended airgap is usually specified in the encoder datasheet. The typical airgap for AS5048a is 1 mm airgap, but it depends on how the strength of the magnet. Improper airgap can cause noise in the signal and faulty readings.</p> </li> <li> <p>If you are trying to configue multiple SPI encoders with a shared bus (same MOSI, MISO, SCLK) but differnt chip select pins (CS), the physical wire lengths significantly affect the signal integrity. The longer the wire, the more the signal degrades. From my exerience, 3 SPI devices on the same bus with 80 MHz CLK had a maximum of 10 cm wire length. If you are using a longer wire, you may need to reduce the SPI CLK frequency. If you are 2 SPI devices, I recommend separating the SPI bus since ESP32 provides 2 SPI interfaces. You can more information <a href="https://randomnerdtutorials.com/esp32-spi-communication-arduino/">here</a>.</p> </li> <li> <h2 id="flashing-the-arduino-code">Flashing the Arduino Code</h2> </li> </ul> <p>Make sure to install <a href="https://docs.simplefoc.com/installation">SimpleFOC</a> and <a href="https://github.com/sandeepmistry/arduino-CAN">Arduio-CAN</a> libraries for Arduino IDE.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/diagram-480.webp 480w,/assets/img/can/diagram-800.webp 800w,/assets/img/can/diagram-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/diagram.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="comm-diagram" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Communication Diagram for Motor Control </div> <p>The host computer will send the desired torque command in <code class="language-plaintext highlighter-rouge">double</code> format to the ESP32 via CAN bus. The ESP32 will receive the torque command and send the current motor position in <code class="language-plaintext highlighter-rouge">double</code> back to the host computer.</p> <p>Since the CAN data can hold up to 8 bytes, we can directly encode the <code class="language-plaintext highlighter-rouge">double</code> data of torque command or motor position into the CAN data buffer with LSB order. Function such as <code class="language-plaintext highlighter-rouge">std::memcpy</code> for C++ or <code class="language-plaintext highlighter-rouge">memcpy</code> in Arduino will take care of packing the <code class="language-plaintext highlighter-rouge">double</code> data into the 1 x 8 byte buffer. However, make sure to check the endianness of the data to make sure the data is packed in LSB order.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void packDouble(double data, uint8_t *dataBuffer) {
    memcpy(dataBuffer, &amp;data, sizeof(double));
}
</code></pre></div></div> <p>Otherwise, we can directly allocate each byte of the <code class="language-plaintext highlighter-rouge">double</code> data into the CAN data buffer like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void packDouble(double data, uint8_t *dataBuffer) {
    uint64_t dataAsInt = *reinterpret_cast&lt;uint64_t*&gt;(&amp;data); // Reinterpret the double as a uint64_t
    dataBuffer[0] = (uint8_t)dataAsInt;
    dataBuffer[1] = (uint8_t)(dataAsInt &gt;&gt; 8);
    dataBuffer[2] = (uint8_t)(dataAsInt &gt;&gt; 16);
    dataBuffer[3] = (uint8_t)(dataAsInt &gt;&gt; 24);
    dataBuffer[4] = (uint8_t)(dataAsInt &gt;&gt; 32);
    dataBuffer[5] = (uint8_t)(dataAsInt &gt;&gt; 40);
    dataBuffer[6] = (uint8_t)(dataAsInt &gt;&gt; 48);
    dataBuffer[7] = (uint8_t)(dataAsInt &gt;&gt; 56);
}
</code></pre></div></div> <p>which is not clean but safe way to pack the data.</p> <p>When a command is recived from the host computer, the ESP32 will send command current to motor by converting the torque command to current command with pre-defiend torque constant and respond with the motor position to the host computer.</p> <p>We can implement a simple <a href="https://blog.mbedded.ninja/programming/operating-systems/linux/how-to-use-socketcan-with-c-in-linux/">C++ code to read and write over SocketCAN</a> to control the motor.</p> <p><a href="http://www.youtube.com/watch?v=8PiBqahbf7M"><img src="http://img.youtube.com/vi/8PiBqahbf7M/0.jpg" alt="Video"/></a></p> <div class="caption"> Motor Cotnrol with SocketCAN. In the video, I only sent float data in ESP32 and received the same float data back from ESP32 instead of double. In this case, the CAN data buffer is 4 bytes instead of 8 bytes. </div> <p>Now we can control the gripper motor using the same setup.</p> <p>Using the linear motion of the belt, we can achieve parallel gripper motion. The belt is connected to the motor shaft and the gripper jaws. When the motor rotates, the belt moves the jaws in the opposite direction.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/gripper_mech-480.webp 480w,/assets/img/can/gripper_mech-800.webp 800w,/assets/img/can/gripper_mech-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/gripper_mech.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="gripper_mech" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Mechanism for the Parallel Gripper with one motor </div> <p>We recorded the joint trajectories including the gripper motor to push the jenga piece and grab it by kinestheic teaching (manually driving the robot). We can use the recorded joint trajectories to replay the same motion.</p> <p><a href="http://www.youtube.com/watch?v=MmSt8G7N8ik"><img src="http://img.youtube.com/vi/MmSt8G7N8ik/0.jpg" alt="Video"/></a></p> <div class="caption"> Optimo Manipulator Pusing and Grabbing a Jenga Block </div>]]></content><author><name></name></author><category term="Hardware Development"/><category term="Robotic Manipulation"/><summary type="html"><![CDATA[Single Motor Control with ESP32, simpleFOC, and SocketCAN for Robotic Gripper]]></summary></entry></feed>