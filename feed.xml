<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://dokkev.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://dokkev.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-01-16T07:05:33+00:00</updated><id>https://dokkev.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">[로봇 하드웨어 04] - 엑추에이터 (3): 유성기어/QDD 감속기</title><link href="https://dokkev.github.io/hardware04/" rel="alternate" type="text/html" title="[로봇 하드웨어 04] - 엑추에이터 (3): 유성기어/QDD 감속기"/><published>2025-12-04T00:00:00+00:00</published><updated>2025-12-04T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-04</id><content type="html" xml:base="https://dokkev.github.io/hardware04/"><![CDATA[<h2 id="유성기어-감속기-planetary-gearbox--epicyclic-gearbox">유성기어 감속기 (Planetary Gearbox / Epicyclic Gearbox)</h2> <p>이번 포스트에서는 유성기어에 대해 알아보겠습니다. 하모닉 드라이브가 큰 감속비와 높은 위치 정밀도에 강점이 있다면, 유성기어는 정밀함보다는 물리적으로 버티는 힘에 최적화된 감속기입니다.</p> <h2 id="유성기어-감속기의-원리">유성기어 감속기의 원리</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/pg-480.webp 480w,/assets/img/hardware/pg-800.webp 800w,/assets/img/hardware/pg-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/pg.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> 유성기어 구조 [1] </div> </div> </div> <p>유성기어는 세 가지 요소로 구성됩니다.</p> <ul> <li>Sun Gear : 중심에 위치한 입력 기어</li> <li>Planet Gears : Sun Gear 주위를 도는 다수의 기어</li> <li>Ring Gear : 외곽을 감싸는 내부 치형 기어</li> <li>(그리고 이들을 묶는 Carrier가 출력축 역할을 합니다)</li> </ul> <p>이 구조의 가장 중요한 특징은 여러 개의 기어가 동시에 힘을 나눠 갖는다는 점입니다 (load distribution). 단일 spur gear에서는 하나의 치면이 대부분의 토크를 감당하지만, 유성기어에서는 여러 개의 행성기어가 동시에 맞물리며 토크와 접촉 응력을 분산시킵니다.</p> <p>행성기어의 개수를 $N$이라 하면, 이상적인 경우 각 행성기어가 전체 토크의 $\frac{1}{N}$만큼만 부담하게 됩니다.</p> <p>행성기어의 개수 N에 따라 이론적으로 토크 전달 능력이 N배로 증가합니다. 현실적으로는 제조 오차, 베어링 backlash, 강성치 불균형 때문에 완벽한 분산은 어렵지만, 단일 기어 대비 접촉 응력이 크게 줄어듭니다.</p> <p>이에 따른 이점은 다음과 같습니다.</p> <ul> <li>치면 파손에 강함</li> <li>반복 고토크 작업에 유리</li> <li>순간적인 충격 흡수 능력 우수</li> </ul> <p>따라서 유성기어는 힘 제어가 중요한 동적 로봇에 자주 사용됩니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/pg-compare-480.webp 480w,/assets/img/hardware/pg-compare-800.webp 800w,/assets/img/hardware/pg-compare-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/pg-compare.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> 유성기어 감속기 동작 예시 [1] </div> </div> </div> <p>유성기어는 어느 요소를 고정하느냐에 따라 다른 감속비와 동작 특성을 가집니다. 다관절 로봇의 경우는 대개 다음과 같이 구성됩니다:</p> <ul> <li>Ring Gear 고정</li> <li>Sun Gear 입력</li> <li>Planet Gear / Carrier 출력</li> </ul> <p>이 구성에서의 감속비는 다음과 같이 정해집니다. \(\text{Gear Ratio} = \frac{\omega_{in}}{\omega_{out}} = 1 + \frac{N_r}{N_s}\)</p> <p>여기서:</p> <ul> <li>$N_r$ : Ring Gear 치 수</li> <li>$N_s$ : Sun Gear 치 수</li> </ul> <p>예를 들어,</p> <ul> <li>Sun = 20 teeth</li> <li>Ring = 80 teeth</li> </ul> <p>라면,</p> \[\text{Gear Ratio} = 1 + \frac{80}{20} = 1 + 4 = 5:1\] <h2 id="유성기어-감속기의-장점">유성기어 감속기의 장점</h2> <h4 id="1-구조적-안정성">1. 구조적 안정성</h4> <p>여러 planet gear 가 토크를 분담하기 때문에 높은 토크를 반복적으로 전달하는 데 유리합니다. 특히 충격 하중이 잦은 동적 로봇에서 신뢰성이 높습니다.</p> <h4 id="2-비용-대비-성능">2. 비용 대비 성능</h4> <p>Spur gear 기반으로 제작 가능한 구조라 정밀 하모닉 드라이브 나 사이클로이드 감속기 대비 제작 비용이 저렴합니다.</p> <h4 id="3-유지보수-용이성">3. 유지보수 용이성</h4> <p>구조가 비교적 단순하고, 피로 파손을 전제로 한 얇은 변형 부품이 없기 때문에 장기 운용 및 유지보수가 수월합니다.</p> <h2 id="유성기어의-감속기의-단점">유성기어의 감속기의 단점</h2> <h4 id="1-감속비-확장성-scalability">1. 감속비 확장성 (Scalability)</h4> <p>유성기어 감속기는 단일 스테이지에서 만들 수 있는 감속비가 제한적입니다. 보통 한 스테이지당 3~10:1 수준이 현실적인 범위이고, 그 이상을 원하면 결국 기어 스테이지를 여러 단 쌓아야 합니다. 이 경우 질량이 증가하고 마찰 손실이 커지며 backlash 가 누적되어 위치 정밀도가 크게 떨어집니다.</p> <h4 id="2-backlash">2. Backlash</h4> <p>대부분의 유성기어 감속기는 spur gear 를 사용합니다. 이 경우, 치합 특성상 미세한 백래시는 구조적으로 피하기 어렵습니다.</p> <p>헬리컬 기어(Helical Gear)를 사용하면 여러 치가 동시에 점진적으로 맞물리면서 백래시와 진동을 줄이면서 힘 전달 효율을 높일 수 있습니다. 하지만 헬리컬 기어에는 트레이드 오프가 존재합니다</p> <ul> <li>치형 각도 때문에 axial force 가 발생</li> <li>하우징 및 캐리어 설계 복잡도 상승</li> <li>제조 비용 증가</li> </ul> <p>Axial force 를 상쇄하기 위해 이중 헬리컬(Double Helical, Herringbone) 구조를 쓰기도 합니다. 이 경우 축방향 힘은 상쇄되지만, 제조 난이도와 비용은 다시 크게 올라갑니다.</p> <h2 id="quasi-direct-drive-qdd-액추에이터에서의-유성기어-감속기">Quasi-Direct Drive (QDD) 액추에이터에서의 유성기어 감속기</h2> <p>QDD(Quasi-Direct Drive) 액추에이터 (이하 QDD)는 기어비를 크게 올려 토크를 만드는 방식과는 다른 방향의 설계 철학을 가집니다. QDD 의 목표는:</p> <ul> <li>모터 로터 관성을 가능한 한 그대로 드러내고</li> <li>기계적 복잡성과 비선형성을 줄이며</li> <li>높은 응답성과 힘-운동 투명성(force-motion transparency)을 확보하는 것</li> </ul> <p>QDD 엑추에이터는 유성기어 감속기에만 국한되지 않고 사이클로이드 감속기, 캡스탄 드라이브 감속기 등 다양한 감속기 구조를 사용할 수 있습니다. 시중에서 판매되는 QDD 액추에이터 중 상당수가 유성기어 감속기를 사용하고 있습니다.</p> <h3 id="qdd-actuator-의-assembly-structure">QDD Actuator 의 Assembly Structure</h3> <p>낮은 기어비를 compenstate 하기 위해 QDD 는 대게 Diameter 가 크고 토크 밀도가 높은 모터를 사용합니다. 그리고 패키징을 컴팩트하게 유지하기 위해 유성기어 감속기를 BLDC Outrunner 모터의 스테이터에 고정하는 구조를 자주 사용합니다. 이 구조는 모터와 감속기를 일체형으로 만들 수 있어 컴팩트한 패키징이 가능합니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/pancake-480.webp 480w,/assets/img/hardware/pancake-800.webp 800w,/assets/img/hardware/pancake-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/pancake.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> QDD 액추에이터 예시 [2] </div> </div> </div> <figure> <iframe width="720" height="405" src="https://www.youtube.com/embed/Mhxz2Bj2RXA" title="MIT Mini Cheetah Actuator Teardown" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""> </iframe> <figcaption style="text-align: center;"> <em>MIT Mini Cheetah Actuator Teardown</em> </figcaption> </figure> <h3 id="forcemotion-transparency-란">Force–Motion Transparency 란?</h3> <p>Force–motion transparency(이하 transparency)는<br/> 원래 <strong>teleoperation 연구 분야</strong>에서 사용되던 개념으로,<br/> 조작자가 로봇을 통해 환경과 상호작용할 때<br/> 마치 <strong>직접 그 환경에 접촉하고 있는 것처럼 느껴지는 정도</strong>를 의미합니다.</p> <p>Teleoperation 문헌에서 transparency는 단순히 “힘이 잘 전달되는가”를 의미하지 않습니다.<br/> 보다 정확하게는, <strong>힘(force)과 운동(motion, 주로 velocity) 정보가<br/> 양방향으로 왜곡 없이 전달되는가</strong>를 뜻합니다.</p> <p>즉,</p> <ul> <li>사용자가 가한 힘이 환경에 그대로 전달되고</li> <li>환경에서 발생한 반력이 다시 사용자에게 즉각적으로 전달되며</li> <li>그 과정에서 속도와 가속 정보 또한 인위적으로 왜곡되지 않는 상태</li> </ul> <p>를 이상적인 transparency 상태로 정의합니다.</p> <p>이를 기계 임피던스 관점에서 보면, transparency는<br/> 힘–속도 관계가 시스템 내부의 마찰, 관성, 히스테리시스 등에 의해<br/> 얼마나 왜곡되는가의 문제로 해석할 수 있습니다.</p> <p>[ Z(s) = \frac{F(s)}{v(s)} = Ms + B + \frac{K}{s} ]</p> <p>여기서</p> <ul> <li>저주파 영역에서는 마찰 및 히스테리시스 항 (B)가</li> <li>고주파 영역에서는 관성 항 (Ms)가<br/> transparency를 제한하는 주요 요인이 됩니다.</li> </ul> <p>이러한 맥락에서 QDD 액추에이터는<br/> 높은 감속비를 통해 토크를 증폭하는 대신,</p> <ul> <li>낮은 감속비를 유지하여 reflected inertia를 줄이고</li> <li>불필요한 기계적 비선형성을 최소화함으로써</li> <li>힘과 운동 정보가 전 주파수 대역에서 자연스럽게 전달되는</li> </ul> <p><strong>높은 force–motion transparency</strong>를 확보하는 것을 목표로 합니다.</p> <h3 id="무엇이-qdd-를-정의하는가">무엇이 QDD 를 정의하는가?</h3> <p>QDD(Quasi-Direct Drive)는 이름 그대로 Direct Drive에 가깝지만,<br/> 실제로 완전한 무감속(direct drive)을 사용하는 경우는 거의 없습니다.<br/> 대부분의 QDD 액추에이터는 <strong>5:1 ~ 10:1 수준의 낮은 감속비</strong>를 사용하며,<br/> 설계 목표와 응용에 따라 <strong>20:1 내외</strong>까지 사용되는 경우도 존재합니다.</p> <p>이 부분은 다소 개인적인 결론에 가깝지만,<br/> 실제로 QDD에 대해 <strong>엄밀하게 합의된 정량적 기준은 존재하지 않습니다.</strong><br/> 대신 업계와 연구 커뮤니티에서는 서로 다른 <strong>두 가지 관점</strong>이 혼재되어 사용되고 있습니다.</p> <p>즉, <strong>N:1 기어비 자체가 QDD의 정의는 아닙니다.</strong></p> <hr/> <h2 id="dynamic-transparency-관점">Dynamic Transparency 관점</h2> <ul> <li>낮은 감속비 (일반적으로 10:1 이하)</li> <li>낮은 reflected inertia를 통해 <strong>높은 control bandwidth 확보</strong></li> <li>빠른 가속·감속과 안정적인 고대역(force–motion) 상호작용이 목표</li> </ul> <p>모터 로터의 관성 모멘트 (J_m)는 감속기를 통해<br/> 관절(output) 측으로 다음과 같이 반사(reflect)됩니다.</p> <p>[ J_{\text{ref}} = J_m N^2 ]</p> <p>여기서 (N)은 기어비입니다.</p> <p>즉, <strong>기어비가 증가할수록 모터 로터의 관성은<br/> 관절에서 (N^2) 배로 증폭되어 보이게 됩니다.</strong></p> <p>많은 로봇 다리 설계는 <strong>proximal actuation</strong><br/> (무거운 액추에이터를 상대적으로 움직임이 적은 몸통 가까이에 배치하는 방식)을 채택합니다.<br/> 이 경우 다리 동역학에서 지배적인 관성은<br/> distal link의 질량이나 관절 하드웨어 자체보다도,<br/> <strong>기어를 통해 반사되는 로터 관성(reflected inertia)</strong> 인 경우가 많습니다.</p> <p>따라서 감속비를 낮게 유지하면</p> <ul> <li>관절에서 느껴지는 reflected inertia가 감소하고</li> <li>접촉·충돌 시 로봇이 더 <em>가볍게</em> 반응하며</li> <li>빠른 방향 전환과 높은 가속이 가능해집니다.</li> </ul> <p>이는 곧 고주파 영역에서의<br/> <strong>force–motion transparency와 제어 대역폭(control bandwidth)</strong> 향상으로 이어집니다.</p> <p>이 관점에서 QDD는</p> <blockquote> <p><em>“반사 관성을 최소화하여 동적 상호작용 성능과 제어 대역폭을 확보하려는 설계 철학”</em><br/> 으로 이해할 수 있습니다.</p> </blockquote> <hr/> <h2 id="quasi-static-force-transparency-관점">(Quasi-static) Force Transparency 관점</h2> <ul> <li>마찰, 기어 손실, 히스테리시스 등 <strong>기계적 비선형성</strong> 최소화</li> <li>별도의 힘 센서 없이 **모터 전류 기반 힘 추정 및 제어 ** (proprioceptive actuation)</li> <li>높은 역구동성(backdrivability) 확보</li> </ul> <p>이 관점에서 중요한 것은<br/> <strong>감속비의 크기 자체가 아니라,<br/> 기계적 비선형성이 저주파 힘 전달을 얼마나 왜곡하는가</strong>입니다.</p> <p>즉,</p> <ul> <li>감속비가 <strong>15~20:1 수준까지 올라가더라도</strong></li> <li>마찰과 히스테리시스가 충분히 작고</li> <li>전류 기반 힘 추정이 신뢰할 수 있으며</li> <li>저속·준정적 상호작용에서 역구동성이 확보된다면,</li> </ul> <p>해당 시스템을 <strong>QDD로 분류</strong>하는 경우도 존재합니다.</p> <p>이 관점에서 QDD는<br/> 저주파 영역에서 힘이 왜곡 없이 전달되는<br/> <strong>높은 force transparency를 갖는 액추에이터</strong>로 이해할 수 있습니다.</p> <h3 id="learning-based-control-과의-시너지-그리고-한계">Learning-based Control 과의 시너지 그리고 한계</h3> <p>이러한 특성들 때문에 QDD 액추에이터는 다이내믹한 움직임을 연구하는 소형 연구용 휴머노이드나 보행 로봇에서 자주 사용됩니다.</p> <p>특히 QDD는 learning-based control, 그중에서도 시뮬레이션 환경에서 시행착오를 통해 정책을 학습하는 reinforcement learning (RL) 기반 접근법과 구조적으로 잘 어울립니다.</p> <p>그 이유는 알고리즘 이전에, 하드웨어의 물리적 성질에 있습니다.</p> <ul> <li>높은 감속비 기어에서 흔히 나타나는 기계적인 비선형성이 상대적으로 적음</li> <li>제어 대역폭이 높아 빠른 동작 전환 가능</li> </ul> <p>하지만 QDD 액추에이터에도 분명한 한계는 존재합니다.<br/> 낮은 감속비를 유지하려면 동일한 관절 토크를 생성하기 위해<br/> 모터가 더 큰 전류와 전력을 직접 소모해야 합니다.</p> <p>이로 인해</p> <ul> <li>모터 동손(copper loss) 증가에 따른 발열 관리 문제가 발생하고</li> <li>배터리 기반 시스템에서는 운용 시간이 단축됩니다</li> </ul> <p>이러한 특성 때문에 QDD는<br/> 큰 payload를 장시간 지속적으로 지탱하거나,<br/> 높은 duty cycle로 반복 작업이 요구되는 환경에서는<br/> 설계 난이도가 크게 증가합니다.</p> <p>전통적인 산업용 로봇 팔에서는<br/> 정밀한 위치 제어와 높은 반복 정밀도를 장시간 안정적으로 유지하는 것이 핵심 요구 조건이었기 때문에,<br/> 외부 하중과 마찰 변화에 둔감한<br/> 높은 감속비 기반의 액추에이터 구조가 주로 사용되어 왔습니다.</p> <p>그러나 최근에는 휴머노이드 로봇을 포함한 차세대 로봇 플랫폼에서도<br/> 산업 현장 적용이 본격적으로 논의되면서,<br/> QDD 기반 액추에이터 역시 하나의 기본 선택지로 자리 잡아가고 있습니다.</p> <p>다만 QDD를 산업 환경에서 안정적으로 운용하기 위해서는,</p> <ul> <li>온도 변화에 따른 모터 torque constant 변화를 보상하는 제어 기법,</li> <li>능동적 또는 수동적 냉각을 포함한 열 관리 설계,</li> <li>높은 전력 소모를 감당하기 위한 메카니즘 설계와 배터리 및 전력 시스템의 최적화,</li> </ul> <p>와 같은 추가적인 시스템 수준의 설계 고려가 필수적입니다.</p> <p>즉, QDD는 산업 환경에 부적합한 구조라기보다는,<br/> 높은 동적 성능과 물리적 상호작용 품질을 대가로<br/> 더 정교한 열·전력·시스템 설계를 요구하는 액추에이터로 이해하는 것이 적절합니다.</p> <h3 id="proprioceptive-actuation">Proprioceptive Actuation</h3> <p>Proprioceptive actuation은<br/> 별도의 힘 또는 토크 센서 없이,<br/> <strong>모터의 내부 상태(주로 전류)를 이용해 출력 토크와 외력을 추정하고 제어하는<br/> 액추에이션 방식</strong>을 의미합니다.</p> <p>보통 이러한 proprioceptive actuation을 실현하기 위한 기계적 조건으로<br/> <strong>낮은 감속비에 force-motion transparency가 높은 Quasi-Direct Drive(QDD) 액추에이터 설계</strong>를 채택합니다.</p> <p>낮은 감속비를 사용함으로써,</p> <ul> <li>기어를 통해 반사되는 로터 관성(reflected inertia)이 감소하고</li> <li>마찰 및 히스테리시스와 같은 비선형성이 줄어들며</li> <li>결과적으로 모터 전류와 출력 토크 사이의 관계가 단순해집니다.</li> </ul> <p>이로 인해,</p> <ul> <li>저주파 영역에서는 외력이 전류 신호에 왜곡 없이 반영되고</li> <li>고주파 영역에서는 관성으로 인한 동적 둔감함이 최소화되어</li> </ul> <p><strong>전 주파수 대역에서 신뢰할 수 있는 force sensing과<br/> 높은 대역폭의 force control이 가능</strong>해집니다.</p> <p>즉, QDD는 proprioceptive actuation 그 자체가 아니라,<br/> 이를 가능하게 만드는 <strong>핵심적인 기계적 수단(enabling design choice)</strong> 으로 이해할 수 있습니다.</p> <p>이러한 로봇 설계 철학을 Proprioceptive Actuation 이라고 부릅니다. 이 부분은 MIT Biomimetic Robotics Lab 연구진의 Proprioceptive Actuator Design in the MIT Cheetah: Impact Mitigation and High-Bandwidth Physical Interaction for Dynamic Legged Robots [3] 논문에서 자세히 다루고 있습니다. 이 시리즈에서도 이후에 Proprioceptive Actuation 에 대해서도 별도로 다룰 예정입니다.</p> <h3 id="references">References</h3> <p>[1] https://www.tec-science.com/mechanical-power-transmission/planetary-gear/epicyclic-planetary-gear/ [2] https://www.semanticscholar.org/paper/A-low-cost-modular-actuator-for-dynamic-robots-Katz/80732f8a46655aa4a1037a7fbdc154f4ceb33c50 [3] https://fab.cba.mit.edu/classes/865.18/motion/papers/mit-cheetah-actuator.pdf</p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - 유성기어/QDD 감속기]]></summary></entry><entry><title type="html">[로봇 하드웨어 03] - 엑추에이터 (2): 하모닉 드라이브 감속기</title><link href="https://dokkev.github.io/hardware03/" rel="alternate" type="text/html" title="[로봇 하드웨어 03] - 엑추에이터 (2): 하모닉 드라이브 감속기"/><published>2025-12-03T00:00:00+00:00</published><updated>2025-12-03T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-03</id><content type="html" xml:base="https://dokkev.github.io/hardware03/"><![CDATA[<h2 id="감속기">감속기</h2> <p>감속기는 모터의 고속·저토크 출력을 저속 회전 저속·고토크 출력으로 변환하는 기계 장치입니다. 일반적인 BLDC 모터는 회전 속도는 충분하지만, 로봇 관절에서 바로 쓰기엔 토크가 턱없이 부족하죠. 그래서 대부분의 관절 구동계에는 감속기가 들어갑니다. 감속기는 기어, 벨트, 케이블, 차동 메커니즘 등 다양한 방식으로 구현할 수 있는데요, 이번 글에서는 그중에서도 로봇 팔에서 많이 쓰이는 하모닉 드라이브(Harmonic Drive), 혹은 Strain Wave Drive를 다뤄보겠습니다.</p> <h2 id="하모닉-드라이브의-원리">하모닉 드라이브의 원리</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/hd-480.webp 480w,/assets/img/hardware/hd-800.webp 800w,/assets/img/hardware/hd-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/hd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/hd-480.webp 480w,/assets/img/hardware/hd-800.webp 800w,/assets/img/hardware/hd-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/hd.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>하모닉 드라이브의 핵심은 의도적으로 변형되는 얇은 spline(gear)입니다. 이 변형된 spline이 다른 고정된 spline과 맞물리면서 회전 운동을 전달하죠. 구성 요소는 크게 세 가지입니다.</p> <ul> <li>Wave Generator (캠) : 타원형 베어링 구조로, 회전하면서 flexspline을 타원형으로 눌러줍니다.</li> <li>Flexspline : 얇은 컵 형태의 금속 기어로, 반복적으로 탄성 변형됩니다. 출력축과 연결된 부품입니다.</li> <li>Circular Spline : 강성이 높은 외곽 기어로, flexspline보다 치 수가 약간 더 많습니다.</li> </ul> <p>동작 원리는 단순하지만 직관적이지 않습니다. 캠이 회전하면서 flexspline을 타원형으로 변형시키면, 특정 두 구간에서만 circular spline과 치합이 일어납니다. 이 상태로 캠이 한 바퀴 도는 동안, 치 수 차이만큼만 상대 회전이 누적됩니다.</p> <p>예를 들어,</p> <ul> <li>Flexspline: 200 teeth</li> <li>Circular spline: 202 teeth</li> </ul> <p>라면, 캠이 한 바퀴 회전할 때 flexspline은 circular spline에 대해 2 teeth 만큼만 뒤처지게 됩니다. 결과적으로 기어비는</p> \[\text{Gear Ratio} = \frac{200}{202-200} = \frac{200}{2} = 100:1\] <p>이렇게 아주 큰 감속비를 단일 스테이지에서 만들어낼 수 있는 게 하모닉 드라이브의 장점입니다. 때문에 Franka Emika Panda / Research Series 같은 연구용으로 많이 쓰이는 Cobot 로봇 팔에서 하모닉 드라이브가 널리 사용되고 있습니다.</p> <p>하모닉 드라이브에서 가장 중요한 동시에, 가장 취약한 부품이 바로 flexspline입니다. 일반적으로 고강도 합금강이나 스테인리스 계열의 박판 금속으로 만들어집니다. 두께는 수백 μm 수준으로 매우 얇고, 매 회전마다 반복적인 탄성 변형 + 국부 응력 집중을 겪습니다. 결과적으로 flexspline의 재질, 두께, 열처리, 잔류응력 관리가 감속기의 정격 토크, 피로 수명, 충격 내성을 거의 결정합니다.</p> <h2 id="하모닉-드라이브의-장점">하모닉 드라이브의 장점</h2> <h4 id="1-공간-효율적인-고감속비">1. 공간 효율적인 고감속비</h4> <p>하모닉 드라이브는 작은 직경, 얇은 두께에서 수십~수백 대 1의 감속비를 구현합니다. 이건 다관절 로봇에서 굉장한 장점입니다</p> <ul> <li>관절 직경 감소</li> <li>링크 단면 축소</li> <li>질량 및 관성 저감</li> </ul> <p>이는 전체 로봇의 동역학 성능으로 이어집니다.</p> <h4 id="2-최소한의-백래시-backlash">2. 최소한의 백래시 (Backlash)</h4> <p>하모닉 드라이브는 일반적인 spur gear와 달리 백래시가 거의 없습니다. 이건 단순 가공 정밀도의 문제가 아니라, 구조적인 특성 덕분입니다.</p> <ul> <li>다수의 치가 동시에 치합</li> <li>Flexspline이 pre-load 된 상태로 circular spline에 눌려 있음</li> </ul> <p>일반적인 Spur gear 에서 백래시 자체는 각 관절당 몇 arcmin 수준으로 보면 작아 보일 수 있습니다. 하지만 다관절 로봇에서는 얘기가 달라집니다.</p> <ul> <li>관절 오차는 직렬로 누적</li> <li>링크 길이가 길수록 task-space 오차로 증폭</li> </ul> <p>예를 들어, 7자유도 로봇 팔에서 각 관절에 spur gear 로 인한 0.33° 정도의 백래시가 있다면 [2], 단순 합산만 해도 <strong>2.31°</strong>의 말단 자세 오차가 생깁니다.</p> <figure> <iframe width="720" height="405" src="https://www.youtube.com/embed/8fYwUV6QV8c" title="What is Backlash?" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""> </iframe> <figcaption style="text-align: center;"> <em>기어 백래시</em> </figcaption> </figure> <h2 id="하모닉-드라이브의-단점">하모닉 드라이브의 단점</h2> <h4 id="1-내구성과-피로">1. 내구성과 피로</h4> <p>flexspline은 구조적으로 반복 탄성 변형을 전제로 동작하는 얇은 금속 쉘입니다. 즉, 정상 동작만 놓고 보면 이미 저주기 피로(low-cycle fatigue) 영역에서 운용되는 부품입니다. 문제는 동적 로봇 시스템에서는 이 반복 변형 위에 설계 단계에서 가정하지 않은 Contact Event 가 중첩된다는 점입니다.</p> <p>정상 구동</p> <ul> <li>캠에 의한 주기적 타원 변형</li> <li>Flexspline 전체에 비교적 예측 가능한 저주기 피로 하중 발생</li> </ul> <p>실제 로봇 운용 환경:</p> <ul> <li>물체와의 접촉이나 예기치 않은 충돌로 인해 시간 폭이 매우 짧은 가파른 임펄스 하중 발생.</li> </ul> <p>하모닉 드라이브의 경우, 이러한 임펄스가 다수의 치로 분산되지 않고 타원 변형이 걸린 제한된 치합 영역으로 집중되며 동시에 flexspline 컵의 루트(root) 단부에 굽힘 응력과 축방향 응력이 중첩됩니다.</p> <p>그 결과, 특정 치합 구간 또는 컵 루트 부위에서 설계 시 가정한 반복 변형 범위를 초과하는 국부적인 과응력(over-stress) 이 발생하게 됩니다. 특히 순간적인 충격에서는 flexspline이 buckling이나 영구 변형으로 바로 이어질 수 있습니다.</p> <h2 id="단점-보완-디자인">단점 보완 디자인</h2> <p>이 한계를 보완하기 위해, 실제 로봇 시스템에서는 종종 하모닉 드라이브 출력 로봇 관절 사이 토크 센서를 넣거나 의도적인 탄성 요소를 추가합니다. 이게 바로 Series Elastic Actuator (SEA) 의 개념입니다. SEA에 대해서는 뒤에서 별도로 자세하게 다루도록 하겠습니다.</p> <p><a href="/hardware04/">다음 포스트 : [로봇 하드웨어 04] - 엑추에이터(3): 유성 기어</a></p> <h3 id="references">References</h3> <p>이 포스트 하모닉 드라이브에 대한 내용은 [2]의 자료를 참고하여 작성되었습니다.</p> <p>[1] https://www.harmonicdrive.net/_hd/content/documents/FBB_DifferentialGear.pdf [2] https://www.cubemars.com/product/ak10-9-v2-0-kv60-robotic-actuator.html</p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - 하모닉 드라이브]]></summary></entry><entry><title type="html">[로봇 하드웨어 02] - 엑추에이터 (1): 모터</title><link href="https://dokkev.github.io/hardware02/" rel="alternate" type="text/html" title="[로봇 하드웨어 02] - 엑추에이터 (1): 모터"/><published>2025-12-02T00:00:00+00:00</published><updated>2025-12-02T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-02</id><content type="html" xml:base="https://dokkev.github.io/hardware02/"><![CDATA[<h2 id="엑추에이터란">엑추에이터란?</h2> <p>엑추에이터(actuator)는 로봇을 실제로 움직이게 만드는 구동 부품입니다. 센서가 환경을 느끼고, 제어기가 판단을 내린다면, 엑추에이터는 그 결과를 물리적인 힘과 운동으로 바꾸는 역할을 합니다.</p> <p>사전적인 의미로 보면, 엑추에이터는 “어떤 시스템에 물리적 움직임을 만들어내는 장치”를 뜻합니다. 이 정의에 따르면,</p> <ul> <li>유압 실린더</li> <li>공압 실린더</li> <li>감속기 없는 전기 모터</li> </ul> <p>모두 엑추에이터에 해당합니다. 즉, 사전적으로는 모터 하나만 있어도 엑추에이터라고 부를 수 있습니다.</p> <p>하지만 로봇 하드웨어 문맥에서 엑추에이터라는 말은 조금 다른 의미로 사용됩니다.</p> <p>다관절 로봇에서 모터 단독으로 관절을 구동하는 경우는 거의 없기 때문입니다. 대부분의 로봇에서는 모터가 빠르게 회전하고 감속기를 통해 속도를 줄이는 대신 토크를 키워 관절을 움직입니다.</p> <p>그래서 로봇 하드웨어에서 “엑추에이터”라고 하면, 보통은 전기 모터 + 감속기를 하나의 구동 단위로 묶어서 지칭합니다.</p> <p>이 조합이 관절의 출력 특성, 역구동성, 발열, 제어 성능을 사실상 결정하게 되죠. 같은 제어기 사용하더라도, 엑추에이터 구성이 달라지면 로봇의 움직임과 접촉 반응은 완전히 달라집니다. 엑추에이터는 로봇 성능의 절반 이상을 차지한다고 해도 과언이 아닙니다.</p> <p>로봇 분야에는 공압식 엑추에이터 (pneumatic actuator) 나, 소프트 재료를 이용한 엑추에이터도 존재합니다. 다만 이 글에서는 이런 엑추에이터들은 범위에서 제외하겠습니다.</p> <p>그래서 이 시리즈에서는 로봇에서 가장 보편적으로 사용되는 전기 모터 기반 엑추에이터를 중심으로 살펴볼 예정입니다. 감속기에 대한 이야기는 다음 글에서 다루고, 이 글에서는 우선 모터가 어떤 구조와 특성을 가지는지부터 살펴보겠습니다.</p> <h2 id="모터의-원리">모터의 원리</h2> <p>로봇 하드웨어를 얘기할때 “모터가 얼마나 좋냐?” 라는 표현을 자주 씁니다. 사실 이 질문의 요지는 모터가 얼마나 큰 토크를 낼 수 있느냐 보단 그 힘을 얼마나 예측 가능게, 빠르게, 일관되게, 그리고 오랫동안 낼 수 있느냐에 더 가깝습니다. 로봇 엑추에이어의 관점에서 모터는 단순히 회전하는 부품이 아니라 제어 가능한 토크의 원천으로 다뤄집니다.</p> <p>모터는 기본적으로 전기 에너지를 회전 운동으로 바꾸는 장치입니다. 모터에는 두 가지 핵심 요소가 있습니다: 자석과 전류가 흐르는 코일 입니다. 영구자석 (permanent magnet) 은 고정된 자기장을 만들고 코일에 전류가 흐르면 또 다른 자기장이 생성됩니다. 이 두 자기장 사이의 상호작용이 회전력을 만들어내죠. 이 힘의 방향은 전류 방향과 자기장 방향에 의해 결정되고, 그 결과 회전 방향의 힘, 즉 토크가 만들어집니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/bldc-480.webp 480w,/assets/img/hardware/bldc-800.webp 800w,/assets/img/hardware/bldc-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/bldc.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> BLDC 모터의 작동 원리 [1] </div> </div> </div> <p>모터에는 여러 종류가 있지만 다관절 로봇의 엑추에이터에선 주로 BLDC (Brushless DC) 모터가 사용됩니다. BLDC 모터는 스테이터에 배치된 여러 상의 코일에 전류를 시간적으로 정밀하게 분배함으로써 자기장 방향을 계속 회전시키는 구조입니다. 이 방식은 브러시가 있는 DC 모터에 비해 마찰이 적어 효율이 높고 내구성이 뛰어나고 정밀한 제어에 유리합니다.</p> <h2 id="bldc-모터의-구조와-종류">BLDC 모터의 구조와 종류</h2> <p>BLDC 모터 내부를 보면 <strong>스테이터(stator)</strong>와 <strong>로터(rotor)</strong>로 구분할 수 있습니다. 스테이터는 말 그대로 정지된 구조물입니다. 코일이 배치되어 있고, 전류를 흘려 시간에 따라 변하는 자기장을 만듭니다. 모터에서 “제어된다” 라고 말하는 대부분의 요소는 이 스테이터 쪽에서 일어납니다.</p> <p>로터는 회전하는 구조물입니다. 영구자석이 부착되어 있고, 스테이터가 만들어낸 자기장을 따라 가장 에너지가 낮은 방향으로 끌려가며 회전합니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/bldc_type-480.webp 480w,/assets/img/hardware/bldc_type-800.webp 800w,/assets/img/hardware/bldc_type-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/bldc_type.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> BLDC 모터의 종류 [2] </div> </div> </div> <p>여기서 로터를 스테이터에 바깥쪽에 두느냐, 안쪽에 두느냐에 따라 모터의 종류가 나뉩니다.</p> <h3 id="inner-runner-모터">Inner Runner 모터</h3> <p>로터가 안쪽에 있고, 스테이터가 바깥쪽을 감싸는 구조의 모터입니다. 일반적으로 우리가 떠올리는 전통적인 모터 형태에 가깝습니다.</p> <p>이 구조의 특징은 다음과 같습니다.</p> <ul> <li>회전 반경이 작고</li> <li>로터 관성이 상대적으로 작으며</li> <li>고속 회전에 유리합니다</li> </ul> <p>모터 자체는 작고 가볍게 유지하면서도, 높은 기어비의 감속기를 통해 충분한 출력 토크를 확보할 수 있기 때문에 컴팩트한 패키징과 비교적 높은 페이로드가 동시에 요구되는 협동로봇(cobot) 에서 이 구조가 자주 선택됩니다.</p> <p>이 경우 관절에서 사용되는 토크의 상당 부분은 모터 자체보다는 감속기에서 증폭된 토크에 의해 만들어집니다. 그래서 inner runner 모터 기반 액추에이터는 큰 외력에 순응하기보다는, 관절을 정확하고 안정적으로 위치 제어하는 용도에 더 적합한 성향을 가집니다.</p> <h3 id="out-runner-모터">Out Runner 모터</h3> <p>로터가 바깥쪽에 있고, 스테이터가 안쪽에 위치한 구조의 모터입니다. 이 구조의 특징은 다음과 같습니다.</p> <ul> <li>회전 반경이 크고</li> <li>로터 관성이 상대적으로 크며</li> <li>직접 구동(Direct Drive) 또는 저감속 구동에 유리합니다</li> </ul> <p>같은 전자기력이라도 힘이 작용하는 반경이 커지면 더 큰 토크를 만들 수 있습니다. 그래서 out runner 모터는 낮은 기어비와 기계적 임피던스가 낮은 감속기와 조합했을 때 장점을 잘 드러냅니다.</p> <p>이 경우 관절에서의 제어 대역폭(control bandwidth) 이 높아지고, 외력에 잘 순응하는 역구동성(backdrivability) 이 확보됩니다. 이러한 특성은 접촉이 잦거나, 빠른 동작 전환이 필요한 로봇에서 특히 중요합니다.</p> <p>그래서 out runner 모터는 로봇 다리 메커니즘처럼 큰 토크와 빠른 응답이 동시에 요구되는 시스템이나, 역동적인 움직임이 중요한 로봇 플랫폼에서 자주 사용됩니다. 높은 역구동성은 로봇이 외부 힘에 민감하게 반응하고, 접촉 과정에서 에너지를 보다 효율적으로 흡수하거나 재활용하는 데에도 도움이 됩니다.</p> <p>이러한 설계 철학은 QDD(Quasi-Direct Drive) 액추에이터에서 대표적으로 나타나며, 이에 대해서는 이후에 따로 다룰 예정입니다.</p> <p>다만 기어비가 낮아질수록 요구 토크를 모터 자체에서 더 많이 만들어야 하므로, 발열이 증가하고 상대적으로 크고 무거운 모터가 필요해지는 트레이드오프가 존재합니다.</p> <h2 id="모터-네이밍-및-외관">모터 네이밍 및 외관</h2> <p>Off-the-shelf 모터를 살펴보면 모터 직경 (Diameter) 과 높이 (Height) 에 따라 모터 넘버 가 결정되는 경우가 많습니다. 대부분의 BLDC 모터에서 이 숫자는 다음을 의미합니다.</p> <ul> <li>앞의 두 자리(또는 세 자리): 모터의 직경(diameter)</li> <li>뒤의 두 자리: 모터의 높이(height, 길이)</li> </ul> <p>예를 들어, 3305 모터는 직경이 약 33mm, 높이가 약 5mm 인 모터를 의미합니다.</p> <p>모터의 외관은 단순한 디자인 요소가 아니라, 모터의 성능과 특성을 결정짓는 중요한 요소입니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/pancake-480.webp 480w,/assets/img/hardware/pancake-800.webp 800w,/assets/img/hardware/pancake-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/pancake.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> MIT Mini Cheetah 에 사용된 Outrunner 팬케이크 모터 [3] </div> </div> </div> <h3 id="지름-diameter">지름 (Diameter)</h3> <p>모터 지름은 토크와 직접적으로 연결됩니다. 회전 반경이 커질수록 같은 전자기력에서도 더 큰 토크 생성 합니다. 그래서 저속·고토크를 모터를 원하는 경우에는 지름이 큰 모터가 유리합니다. 특히 out runner나 “팬케이크” 모터에서 이 특성이 두드러집니다.</p> <p>팬케이크 모터는 공식 규격이라기보다는 형상 비율을 설명하는 이름입니다. 지름은 크고 높이는 매우 얇은 형태의 이런 모터들은 토크를 반경으로 만들고, 축 방향 공간을 아끼려는 설계에 적합합니다.</p> <h3 id="높이-height">높이 (Height)</h3> <p>모터의 높이는 순간적인 최대 출력보다는 연속 출력과 발열 특성과 더 밀접하게 관련됩니다.</p> <p>권선 (Winding) 길이가 길어지면서 저항과 자속 경로가 안정되고 모터 내부의 열 용량이 증가하며 결과적으로 연속 토크 (continous torque) 를 유지하기에 유리해집니다.</p> <p>같은 지름을 가진 모터라도 높이가 다른 경우에는 얼마나 오랫동안 토크를 유지할 수 있는지에서 차이가 납니다.</p> <p>이런 특성 때문에 높이가 긴 모터는 발열을 잡는게 중여한 연속 구동 환경이나, 축 방향 공간을 활용하기 쉬운 리니어 액추에이터 구조에서 자주 사용됩니다.</p> <h2 id="bldc-모터에서-전압-전류-토크">BLDC 모터에서 전압, 전류, 토크</h2> <p>모터에서 전류를 흘린다는 건, 단순히 “모터를 켠다”는 의미가 아니라 자기장의 크기와 방향을 직접 조절한다는 뜻입니다.</p> <p>이 자기장의 세기를 결정하는 것이 전류이고, 그 결과로 만들어지는 값이 토크입니다. 그래서 BLDC 모터의 토크는 대부분의 동작 영역에서 전류에 비례한다고 설명됩니다.</p> <p>하지만 여기서 한 가지를 빠뜨리면 안 됩니다. 전류는 전압 없이는 흐르지 않습니다. BLDC 모터에서</p> <ul> <li>전류는 토크의 크기를 결정하고,</li> <li>전압은 그 전류를 얼마나 빨리, 얼마나 크게 흐르게 할지를 결정합니다.</li> </ul> <p>따라서 전압은 토크를 직접 만들지는 않지만 토크를 만들 수 있는 조건과 한계를 결정합니다.</p> <h3 id="전압-한계와-back-emf">전압 한계와 Back-EMF</h3> <p>모터가 회전할 때, 코일 내부에서는 역기전력(Back-EMF)이 발생합니다. 속도가 낮을 때는 입력 전압 대부분이 전류를 흘리는 데 사용되지만, 속도가 올라갈수록 back-EMF가 커지고 실제로 전류를 밀어 넣을 수 있는 여유 전압이 줄어듭니다</p> <p>결과적으로 고속 영역에서는 전류가 제한되고,토크는 자연스럽게 감소합니다.</p> <p>이 현상은 반대 방향에서도 동일하게 나타납니다. 외력에 의해 모터가 역구동될 경우에도 로터의 움직임에 의해 back-EMF가 발생합니다. 이 때 모터는 발전기처럼 동작하게 됩니다. 이때 코일에는 전압이 유도되고, 회로가 닫혀 (closed circuit condition) 있다면 전류가 흐를 수 있습니다. 이 전류는 저항과 인덕턴스를 통해 열로 소모되거나 드라이버와 전원 쪽으로 되돌아가거나 회로 구성에 따라 서로 다른 방식으로 처리됩니다. 자세한 부분은 모터 제어기 부분에서 다루도록 하겠습니다.</p> <h3 id="발열과-토크">발열과 토크</h3> <p>모터에서 발생하는 대부분의 문제는 결국 열에서 비롯됩니다. 로봇이 장시간 동작할 때 액추에이터 성능이 떨어지거나, 고장으로 이어지는 주요 원인 중 하나가 바로 모터의 발열입니다.</p> <div class="row mt-3"> <div class="col-sm-6 mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/torque_current-480.webp 480w,/assets/img/hardware/torque_current-800.webp 800w,/assets/img/hardware/torque_current-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/torque_current.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> 전류에 의한 열 손실 [4] </div> </div> <div class="col-sm-6 mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardware/motor_thermal_limit-480.webp 480w,/assets/img/hardware/motor_thermal_limit-800.webp 800w,/assets/img/hardware/motor_thermal_limit-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardware/motor_thermal_limit.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> 모터의 속도 와 토크 [4] </div> </div> </div> <p>모터에서의 발열은 단순히 “뜨거워진다”에서 끝나지 않습니다. 온도가 올라가면</p> <ul> <li>권선 저항이 증가하고</li> <li>영구자석의 자속 밀도가 감소하며</li> <li>같은 전류에서 만들어지는 토크가 줄어듭니다</li> </ul> <p>즉, 토크 상수 자체가 발열 상태에 따라 변하게 됩니다.</p> <p>이 변화는 갑작스럽게 나타나지 않기 때문에 짧은 실험이나 단발성 테스트에서는 잘 드러나지 않습니다. 하지만 연속 동작이나 반복 작업에서는 제어 성능 저하로 분명하게 나타납니다.</p> <p>그래서 모터 데이터시트에서 가장 중요한 값은 stall 토크가 아니라 연속 토크 (continuous torque / rated torque)입니다. 연속 토크란 허용 온도 범위 내에서 장시간 유지할 수 있는 토크를 의미합니다. 로봇 액추에이터 설계에서 장시간 이 값을 넘어서 사용하기 시작하면, 문제는 시간차를 두고 드러납니다.</p> <p><a href="/hardware03/">다음 포스트 : [로봇 하드웨어 03] - 엑추에이터(2): 감속기</a></p> <h3 id="references">References</h3> <p>[1] https://docs.espressif.com/projects/esp-iot-solution/en/release-v2.0/motor/bldc/bldc_overview.html [2] https://www.gian-transmission.com/a-comprehensive-guide-to-brushless-dc-motor/ [3] https://www.semanticscholar.org/paper/A-low-cost-modular-actuator-for-dynamic-robots-Katz/80732f8a46655aa4a1037a7fbdc154f4ceb33c50 [4] https://things-in-motion.blogspot.com/2019/05/understanding-bldc-pmsm-electric-motors.html</p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - 모터]]></summary></entry><entry><title type="html">[로봇 하드웨어 01] - 로봇 하드웨어란?</title><link href="https://dokkev.github.io/hardware01/" rel="alternate" type="text/html" title="[로봇 하드웨어 01] - 로봇 하드웨어란?"/><published>2025-12-01T00:00:00+00:00</published><updated>2025-12-01T00:00:00+00:00</updated><id>https://dokkev.github.io/hardware-01</id><content type="html" xml:base="https://dokkev.github.io/hardware01/"><![CDATA[<p><a href="/hardware01/">로봇 하드웨어 01 : 로봇 하드웨어란?</a> <a href="/hardware02/">로봇 하드웨어 02 : 엑추에이터(1): 모터</a> <a href="/hardware03/">로봇 하드웨어 03 : 엑추에이터(2): 감속기</a></p> <h2 id="로봇-하드웨어란-무엇일까">로봇 하드웨어란 무엇일까?</h2> <p>로봇 하드웨어라고 하면 보통 모터나 프레임 같은 눈에 보이는 부품을 먼저 떠올리게 됩니다. 사전적인 의미로만 보면 하드웨어는 단순히 물리적인 구성요소를 뜻합니다. 그런데 다관절 로봇에서 말하는 하드웨어는 구동 메커니즘, 센서, 제어 PC 을 넘어서 모터를 높은 주기에서 제어하는 임베비드 시스템, 제어 PC 와의 통신을 위한 네트워크 구성, 중력 보상 같은 물리 모델 기반 제어, 그리고 보행 로봇이 넘어지지 않기 위한 CoM (Center of Mass) 제어나 기본적인 안정성을 확보하기 위한 최적제어 계열의 제어기까지도 많은 경우 로봇에서는 “하드웨어 레벨”로 묶어서 이야기해요.</p> <p>엄밀히 말하면 이런 것들은 소프트웨어에 속하지만, 이런 요소들이 갖춰져 있지 않으면 로봇은 실험이나 데이터 수집이 가능한 상태까지조차 도달하지 못하기 때문이죠.</p> <p>그래서 로봇 하드웨어를 단순히 “모터가 많이 달린 기계” 정도로 생각하면 중요한 부분을 놓치게 됩니다. 요즘 많이 이야기되는 Physical AI 관점에서 보면, 로봇은 단순히 명령을 실행하는 기계라 아니라 물리 세계와 직접 상호작용하는 지능형 시스템에 가깝습니다. 로봇은 직접 힘을 전달하고, 그 힘에 대한 반작용으로 환경이 변하며, 그 변화를 다시 센서를 통해 감지하죠. 이 과정의 중심에는 항상 하드웨어가 있습니다.</p> <p>다양한 다관절 로봇들이 구조적인 외관은 서로 비슷해 보여도, 실제로 환경과 상호작용하는 방식은 하드웨어마다 크게 다릅니다. 같은 관절 구조처럼 보여도 감속기의 종류와 재질, 감속비에 따라 출력 임피던스와 역구동성 (backdrivability)이 달라지고, 이는 접촉 순간 로봇이 얼마나 단단하게 혹은 부드럽게 반응하는지를 직접적으로 바뀝니다.</p> <p>여기에 로봇 전체의 질량 분포와 관성이 더해지면 같은 제어 입력이라도 실제로 전달되는 힘과 가속도는 완전히 달라집니다. 특히 조작 (manipulation) 이나 보행 (locomotion) 처럼 반복적인 접촉이 포함된 작업에서는 이 차이가 안정성이나 성공률로 바로 이어지죠.</p> <p>센서와 제어 쪽도 마찬가지입니다. 제어 주기, 통신 지연과 노이즈, 센서의 감도와 선형성, 히스테리시스 특성은 여기에 구조 강성, 관절 강성, 마찰 같은 요소까지 더해지면, 로봇이 만들어내는 상호작용은 수많은 고전역학적·전자기학적 특성들이 결합된 결과가 됩니다.</p> <h2 id="ai-와-로봇-하드웨어">AI 와 로봇 하드웨어</h2> <p>이런 다양한 하드웨어 요소들 때문에, 로봇의 상호작용을 시뮬레이션에서 완전히 재현하는 데에는 본질적인 한계가 있습니다. 마찰, 구조 유연성, 센서 비선형성, 통신 지연처럼 작아 보이는 요소들이 실제 상호작용에서는 지배적인 역할을 하는 경우가 많기 때문이죠.</p> <p>이 때문에 최근 많이 시도되는 AI 기반 접근법, 특히 강화학습 (Reinforcement Learning) 기반 제어 및 정책 학습에서는 시뮬레이션만으로 학습한 모델이 실제 로봇에서 그대로 동작하기 어려운 경우가 많습니니다. 흔히 이를 “sim-to-real gap” 라고 부릅니다. 로봇이 환경과 주고받는 힘과 반응은 결국 하드웨어가 만들어내는 물리적 특성 위에서 결정되기 때문이에요.</p> <p>더 큰 문제는 이 물리적 특성이 로봇마다 다르다는 점입니다. 한 로봇에서 수집한 데이터나 학습된 제어기가 다른 로봇에서는 동일한 성능을 내지 못하는 경우가 대부분이죠. 그래서 실제 로봇으로 데이터를 수집하는 일 자체도 어려울 뿐더러, 서로 다른 플랫폼 간에 데이터를 공유하거나 재사용하는 일은 더 까다롭습니다.</p> <p>이런 관점에서 보면, AI 기반 로봇 제어의 한계는 알고리즘 그 자체보다 하드웨어가 규정하는 물리적 조건에서 비롯되는 경우가 많습니다. 하드웨어를 이해하지 않고서는 AI가 왜 실패하는지, 어디까지 가능한지도 설명하기 어렵습니다.</p> <h2 id="로봇-하드웨어의-이해">로봇 하드웨어의 이해</h2> <p>그래서 이 블로그에서는 로봇 하드웨어를 여러 계층으로 나눠서 이야기해보려고 합니다. 눈에 보이는 기계 구조와 액추에이터부터, 이를 실제로 움직이게 만드는 구동 메커니즘과 센서, 그리고 low-level 제어와 물리 모델 기반 제어까지 다관절 로봇이 동작하기 위해 필요한 하드웨어 요소들을 단계별로 살펴볼 생각입니다.</p> <p>각 계층이 어떤 역할을 하고, 어디에서 한계가 생기며, 그 한계가 실제 로봇의 성능이나 AI 기반 제어에 어떻게 영향을 주는지도 함께 짚어보려고 합니다. 로봇을 단순히 사용하는 입장이 아니라, 직접 다루고, 고치고, 설계해야 하는 관점에서 정리해보는 게 목표입니다.</p> <p><a href="/hardware02/">다음 포스트 : [로봇 하드웨어 02] - 엑추에이터(1): 모터</a></p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[Physical AI 관점에서 본 다관절 로봇 하드웨어 - 서론]]></summary></entry><entry><title type="html">Hardware Table</title><link href="https://dokkev.github.io/blog/2025/hardware-table/" rel="alternate" type="text/html" title="Hardware Table"/><published>2025-11-30T00:00:00+00:00</published><updated>2025-11-30T00:00:00+00:00</updated><id>https://dokkev.github.io/blog/2025/hardware-table</id><content type="html" xml:base="https://dokkev.github.io/blog/2025/hardware-table/"><![CDATA[<p>01 - 로봇 하드웨어란? 02 - 엑추에이터 (1): 모터 03 - 엑추에이터 (2): 하모닉 드라이브 감속기 04 - 엑추에이어 (3): 유성기어 감속기 05 - 엑추에이터 (4): 사이클로이드 감속기 06 - 엑추에이터 (5): 캡스탄 드라이브 감속기 06 - 엑추에이터 (5): 리니어 액추에이터 07 - 엑추에이터 (6): Self-Locking 감속기 08 - 엑추에이터 (7): 모터 드라이버 09 - 엑추에이터 (8): 서보 모터 10 - 전달 메카니즘(1) - Linkage 11 - 전달 메카니즘(2) - Belt 12 - 전달 메카니즘(3) - Cable / Tendon 13 - 전달 메카니즘(4) - Differential Mechanism 14 - 전달 메카니즘(5) - CVT 15 - 탄성 기반 메카니즘 (1) - Series Elastic Actuator 16 - 탄성 기반 메카니즘 (2) - Parallel Elastic Actuator 17 - 탄성 기반 메카니즘 (3) - Variable Stiffness Actuator 18 - 설계 전략 (2) - Proprioceptive Actuation 19 - 설계 전략 (3) - Underactuation 20 - 설계 전략 (4) - Adaptive/Compliant Mechanism 21 - 설계 전략 (5) - ICR Joint 22 - 센서 (1) - Position Encoder 23 - 센서 (2) - Force Torque Sensor 24 - 센서 (3) - Tactile Sensor 25 - 센서 (4) - IMU 26 - 통신 (1) - I2C/SPI/SSI/UART 27 - 통신 (2) - CAN/RS485/EtherCAT 28 - 물리 모델링 (1) - Friction Model 29 - 물리 모델링 (2) - Contact Model 30 - 물리 모델링 (3) - Impact &amp; Collision Model 31 - 동역학 제어 (1) - Rigid Body Dynamics 32 - 동역학 제어 (2) - Impedance/Admittance Control 33 - 동역학 제어 (3) - Operational Space / Whole Body Controller 34 - 동역학 제어 (4) - Passive Dynamics 35 - 동역학 제어 (5) - System Identification 36 - 제어 시스템 아키텍처 (1) - Real-Time Control 37 - 제어 시스템 아키텍처 (2) - GPU Acceleration 38 - 제어 시스템 아키텍처 (3) - 통신 인터페이스 (PCIe / USB / Ethernet)</p>]]></content><author><name></name></author><summary type="html"><![CDATA[01 - 로봇 하드웨어란? 02 - 엑추에이터 (1): 모터 03 - 엑추에이터 (2): 하모닉 드라이브 감속기 04 - 엑추에이어 (3): 유성기어 감속기 05 - 엑추에이터 (4): 사이클로이드 감속기 06 - 엑추에이터 (5): 캡스탄 드라이브 감속기 06 - 엑추에이터 (5): 리니어 액추에이터 07 - 엑추에이터 (6): Self-Locking 감속기 08 - 엑추에이터 (7): 모터 드라이버 09 - 엑추에이터 (8): 서보 모터 10 - 전달 메카니즘(1) - Linkage 11 - 전달 메카니즘(2) - Belt 12 - 전달 메카니즘(3) - Cable / Tendon 13 - 전달 메카니즘(4) - Differential Mechanism 14 - 전달 메카니즘(5) - CVT 15 - 탄성 기반 메카니즘 (1) - Series Elastic Actuator 16 - 탄성 기반 메카니즘 (2) - Parallel Elastic Actuator 17 - 탄성 기반 메카니즘 (3) - Variable Stiffness Actuator 18 - 설계 전략 (2) - Proprioceptive Actuation 19 - 설계 전략 (3) - Underactuation 20 - 설계 전략 (4) - Adaptive/Compliant Mechanism 21 - 설계 전략 (5) - ICR Joint 22 - 센서 (1) - Position Encoder 23 - 센서 (2) - Force Torque Sensor 24 - 센서 (3) - Tactile Sensor 25 - 센서 (4) - IMU 26 - 통신 (1) - I2C/SPI/SSI/UART 27 - 통신 (2) - CAN/RS485/EtherCAT 28 - 물리 모델링 (1) - Friction Model 29 - 물리 모델링 (2) - Contact Model 30 - 물리 모델링 (3) - Impact &amp; Collision Model 31 - 동역학 제어 (1) - Rigid Body Dynamics 32 - 동역학 제어 (2) - Impedance/Admittance Control 33 - 동역학 제어 (3) - Operational Space / Whole Body Controller 34 - 동역학 제어 (4) - Passive Dynamics 35 - 동역학 제어 (5) - System Identification 36 - 제어 시스템 아키텍처 (1) - Real-Time Control 37 - 제어 시스템 아키텍처 (2) - GPU Acceleration 38 - 제어 시스템 아키텍처 (3) - 통신 인터페이스 (PCIe / USB / Ethernet)]]></summary></entry><entry><title type="html">Resources for Learning Robotics</title><link href="https://dokkev.github.io/Intro-to-Robotics/" rel="alternate" type="text/html" title="Resources for Learning Robotics"/><published>2024-04-12T00:00:00+00:00</published><updated>2024-04-12T00:00:00+00:00</updated><id>https://dokkev.github.io/Intro-to-Robotics</id><content type="html" xml:base="https://dokkev.github.io/Intro-to-Robotics/"><![CDATA[<p>Robotics research requires multidisciplinary knowledge in mathematics, mechanical engineering, electrical engineering, computer engineering, and computer science. This post provides a collection of resources for learning robotics for beginners.</p> <h2 id="fundamental-robotics-knowledge">Fundamental Robotics Knowledge</h2> <p>Short videos that explain the basic concepts of robotics.</p> <h3 id="robot-configuration">Robot Configuration</h3> <ul> <li><a href="https://www.youtube.com/watch?v=zjMuIxRvygQ&amp;t=33s">Quaternions and Rotation in 3D Space, explained interactively</a></li> <li><a href="https://www.youtube.com/watch?v=d4EgbgTm0Bg&amp;t=469s">Visualizing quaternions (4d numbers) with stereographic projection</a></li> <li><a href="https://www.youtube.com/watch?v=zc8b2Jo7mno">Explaining Gibmal Lock</a></li> <li><a href="https://www.youtube.com/watch?v=FyLNR3edOds&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=6">Configuration Space</a></li> <li><a href="https://www.youtube.com/watch?v=hTuW51CpUg4&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=9">Task Space and Workspace</a></li> <li><a href="https://www.youtube.com/watch?v=mvGZtO_ruj0&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=17">Twist</a></li> <li><a href="https://www.youtube.com/watch?v=0wsYPJPGtKE&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=20">Wrenches</a></li> </ul> <h3 id="coordinate-transformation">Coordinate Transformation</h3> <ul> <li><a href="https://www.youtube.com/watch?v=lVjFhNv2N8o">Robotics 1 U1 (Kinematics) S3 (Rotation Matrices) P1 (Rotation Matrices)</a></li> <li><a href="https://www.youtube.com/watch?v=H_94DTWd8ck">2D Coordinate Transformation</a></li> <li><a href="https://www.youtube.com/watch?v=rHLEWRxRGiM">3D Coordinate Transformation</a></li> </ul> <h3 id="robot-kinematics">Robot Kinematics</h3> <ul> <li><a href="https://www.youtube.com/watch?v=bohL918kXQk">Jacobian Matrix</a></li> <li><a href="https://www.youtube.com/watch?v=hhFzJvaY__U&amp;t=510s">Change of Variables and the Jacobian</a></li> <li><a href="https://www.youtube.com/watch?v=vCEWORZbD3Y&amp;t=55s">Robot Singularities</a></li> <li><a href="https://www.youtube.com/watch?v=vjJgTvnQpBs&amp;t=93s">Singularities</a></li> <li><a href="https://www.youtube.com/watch?v=wgpgNLEEpeY">2D Inverse Kinematics with Graphic Visualization</a></li> <li><a href="https://www.youtube.com/watch?v=VhUA0jf7tI8">Numerical Inverse Kinematics (1)</a></li> <li><a href="https://www.youtube.com/watch?v=24cXvgQl-nk">Numerical Inverse Kinematics (2)</a></li> <li><a href="https://www.youtube.com/watch?v=eQ9E0Zvp9jw&amp;t=198s">Odometery</a></li> </ul> <h3 id="robot-dynamics-and-control">Robot Dynamics and Control</h3> <ul> <li><a href="https://ethz.ch/content/dam/ethz/special-interest/mavt/robotics-n-intelligent-systems/rsl-dam/documents/RobotDynamics2017/RD_HS2017script.pdf">ETH Zurich Robot Dynamics Lecture Notes</a></li> <li><a href="https://www.youtube.com/watch?v=8UtnDaGHpq0">Introduction to Lagrangian Mechanics</a></li> <li><a href="http://www.aoengr.com/Dynamics/LagrangianMechanicsPendulum.pdf">Simple Pendulum via Lagrangian Mechanics</a></li> <li><a href="https://www.youtube.com/watch?v=1U6y_68CjeY">Lagrangian Formulation of Robot Dynamics</a></li> <li><a href="https://www.youtube.com/watch?v=ZASVKAlegfQ">Inverse Dynamics</a></li> <li><a href="https://www.youtube.com/watch?v=5A39Ht9Wcu0">Largangian Multipliers</a></li> <li><a href="https://www.youtube.com/watch?v=keMzpa_iWjs">Constrained Lagrangian Mechanics</a></li> <li><a href="https://www.youtube.com/watch?v=_bWvXn4ilrY">PID Control Explained with Robotics</a></li> <li><a href="https://www.youtube.com/watch?v=IolG5V_skv8">Imedpance and Admittance Control</a></li> <li><a href="https://www.youtube.com/watch?v=iQa01aFgf8U">Task Space Dynamics</a></li> <li><a href="https://www.youtube.com/watch?v=GMnO6qntsYc">Redundant Manipulator Control with Nullspace Projection</a></li> <li><a href="https://www.youtube.com/watch?v=UR0GpaaBVKk">Hybrid Position/Force Control</a></li> <li><a href="https://www.youtube.com/watch?v=YwodGM2eoy4">Model Predictive Control</a></li> <li><a href="https://www.youtube.com/watch?v=-FvrON0OmYc">Anatomy of a Dynamical System</a></li> </ul> <h3 id="motion-planning">Motion Planning</h3> <ul> <li><a href="https://www.youtube.com/watch?v=Ob3BIJkQJEw">RRT</a></li> <li><a href="https://www.youtube.com/watch?v=s2qrMwqm4D0&amp;list=PLggLP4f-rq02vX0OQQ5vrCxbJrzamYDfx&amp;index=51">Motion Planning in C-Space</a></li> <li><a href="https://msl.cs.illinois.edu/~lavalle/papers/Lav11b.pdf">Motion Planning Tutorial</a></li> </ul> <h3 id="robot-electronics-and-embedded-system">Robot Electronics and Embedded System</h3> <ul> <li><a href="https://www.youtube.com/watch?v=bCEiOnuODac">BLDC Motors</a></li> <li><a href="https://www.youtube.com/watch?v=KmnztbTCvxM">DC Motor Speed-Torque Plane</a></li> <li><a href="https://www.youtube.com/watch?v=pxtRlKs0pAg">DC Motor Speed-Torque Curve</a></li> <li><a href="https://www.youtube.com/watch?v=YPD1_rcXBIE">Field Oriented Control</a></li> <li><a href="https://www.youtube.com/watch?v=JgnPSOUoVJI">Back EMF</a></li> <li><a href="https://www.youtube.com/watch?v=k2GQVJ4z0kM">Encoder</a></li> <li><a href="https://www.youtube.com/watch?v=IyGwvGzrqp8">Serial Communication</a></li> <li><a href="https://www.youtube.com/watch?v=WikQ5n1QXQs">Control Area Network (CAN)</a></li> <li><a href="https://www.youtube.com/watch?v=tYAl2jkaB8Q">EtherCAT</a></li> </ul> <h3 id="robot-mechanism">Robot Mechanism</h3> <ul> <li><a href="https://www.youtube.com/watch?v=VvYSrsqALKc">Reflection of a Motor</a></li> <li><a href="https://www.youtube.com/watch?v=zI64DyaRUvQ">Degrees of Freedom of a Robot</a></li> <li><a href="https://underactuated.mit.edu/intro.html">Underactuated Systems</a></li> <li><a href="https://www.youtube.com/watch?v=8q25EUszBSI">Bearing</a></li> <li><a href="https://www.youtube.com/watch?v=ZhDO16FDmxA&amp;t=55s">Gears</a></li> <li><a href="https://khkgears.net/new/gear_knowledge/gear_technical_reference/gear_backlash.html">Backlash</a></li> <li><a href="https://www.youtube.com/watch?v=TzJkD87eQNI">Planetary Gears</a></li> <li><a href="https://www.youtube.com/watch?v=C_khtPviVPg">Timing Belts and Pulleys</a></li> <li><a href="https://www.youtube.com/watch?v=uJiauHFUbn8">Cable-Driven Transmission</a></li> <li><a href="https://www.youtube.com/watch?v=gZLO2Am0Zk8">Series Elastic Actuators</a></li> <li><a href="https://www.youtube.com/watch?v=Mhxz2Bj2RXA">MIT Mini Cheetah Actuator Teardown</a></li> <li><a href="https://www.youtube.com/watch?v=VZKsla53FAw">Stiffness and Damping Identification</a></li> <li><a href="https://www.youtube.com/watch?v=TQiLLcumqDw">Rolling Contact Joint</a></li> </ul> <h3 id="machine-learning">Machine Learning</h3> <ul> <li><a href="https://www.youtube.com/watch?v=yMgFHbjbAW8">Residual and Least Squares Regression</a></li> <li><a href="https://www.youtube.com/watch?v=aircAruvnKk&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi">Neural Network</a></li> <li><a href="https://www.youtube.com/watch?v=EKbFIWANwHw">Gradient Descent</a></li> <li><a href="https://www.youtube.com/watch?v=IHZwWFHWa-w&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&amp;index=2">Graident Descent in Deep Learning</a></li> <li><a href="https://www.youtube.com/watch?v=oJNHXPs0XDk">Neural Network Architectures</a></li> <li><a href="https://www.youtube.com/watch?v=Ilg3gGewQ5U&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&amp;index=3">Backpropagation</a></li> <li><a href="https://www.youtube.com/watch?v=wjZofJX0v4M&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&amp;index=5">Transformer (1)</a></li> <li><a href="https://www.youtube.com/watch?v=eMlx5fFNoYc&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&amp;index=6">Transformer (2)</a></li> </ul> <h3 id="locomotion">Locomotion</h3> <ul> <li><a href="https://www.youtube.com/watch?v=Pt_ikHJnNs4">Zero Moment Point</a></li> </ul> <hr/> <h2 id="robot-operating-system-ros">Robot Operating System (ROS)</h2> <ul> <li><a href="https://docs.ros.org/en/iron/index.html">ROS 2 Documentation</a></li> <li><a href="https://docs.ros.org/en/iron/Tutorials.html">Official ROS 2 Tutorials</a></li> <li><a href="https://articulatedrobotics.xyz/page4/">ROS 2 Tutorials</a> by <a href="https://www.youtube.com/@ArticulatedRobotics">Articulated Robotics</a></li> <li><a href="https://industrial-training-master.readthedocs.io/en/melodic/_source/session3/Intro-to-URDF.html">URDF</a></li> </ul> <hr/> <p>Online Courses</p> <p>Online lecture series and courses on robotics.</p> <h2 id="mathematics">Mathematics</h2> <h3 id="linear-algebra">Linear Algebra</h3> <ul> <li><a href="https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/">Linear Algebra</a> by Gilbert Strang at MIT</li> <li><a href="https://www.3blue1brown.com/topics/linear-algebra">Essence of Linear Algebra</a> by Grant Sanderson (<a href="https://www.youtube.com/@3blue1brown">3Blue1Brown</a>)</li> <li><a href="https://www.khanacademy.org/math/linear-algebra">Linear Algebra</a> by Khan Academy</li> </ul> <h3 id="differential-equation">Differential Equation</h3> <ul> <li><a href="https://www.khanacademy.org/math/differential-equations">Differential Equation</a>by Khan Academy</li> </ul> <h3 id="probability">Probability</h3> <ul> <li><a href="https://www.youtube.com/playlist?list=PL2SOU6wwxB0uwwH80KTQ6ht66KWxbzTIo">Statistics 110: Probability</a> by Joe Blitzstein at Harvard University</li> </ul> <hr/> <h2 id="robot-mechanics-design-and-control">Robot Mechanics, Design, and Control</h2> <h3 id="robotic-manipulation">Robotic Manipulation</h3> <ul> <li><a href="https://modernrobotics.northwestern.edu/nu-gm-book-resource/foundations-of-robot-motion/">Modern Robotics</a> by Kevin Lynch at Northwestern University</li> <li><a href="https://manipulation.csail.mit.edu/index.html">Robotic Manipulation</a> by Russ Tedrake at MIT</li> </ul> <h3 id="robot-mechanism-design">Robot Mechanism Design</h3> <ul> <li><a href="https://www.youtube.com/@StanfordCS235/videos">Applied Robot Design</a>by Reuben Brewer at Stanford University</li> </ul> <h3 id="robot-control">Robot Control</h3> <ul> <li><a href="https://underactuated.mit.edu/index.html">Underacutated Robotics</a> by Russ Tedrake at MIT</li> <li><a href="https://web.stanford.edu/class/ee364a/">Convex Optimization</a> by Stephen Boyd at Stanford University</li> <li><a href="https://www.youtube.com/watch?v=Kj88Nory8ec&amp;list=PLZnJoM76RM6Jv4f7E7RnzW4rijTUTPI4u">Optimal Control</a> by Zachery Manchester at CMU</li> <li><a href="https://www.youtube.com/watch?v=Pi7l8mMjYVE&amp;list=PLMrJAkhIeNNR20Mz-VpzgfQs5zrYi085m">Control Bootcamp</a> by Steven Brunton at University of Washington</li> </ul> <p>https://people.eecs.berkeley.edu/~pabbeel/cs287-fa19/</p> <h2 id="robot-perception-and-navigation">Robot Perception and Navigation</h2> <h3 id="computer-vision">Computer Vision</h3> <ul> <li><a href="https://www.youtube.com/playlist?list=PLzWRmD0Vi2KVsrCqA4VnztE4t71KnTnP5">Modern Computer Vision</a> at UC Berkeley <h3 id="slam">SLAM</h3> </li> <li><a href="https://www.youtube.com/watch?v=U6vr3iNrwRA&amp;list=PLgnQpQtFTOGQrZ4O5QzbIHgl3b1JHimN_&amp;index=1">Robot Mapping</a> by Cyrill Stachniss at University of Bonn</li> </ul> <h2 id="embedded-system">Embedded System</h2> <ul> <li><a href="https://users.ece.utexas.edu/~valvano/Volume1/">Intro to Embedded Systems</a> by Jonathan Valvano at UT Austin <ul> <li><a href="https://www.edx.org/learn/embedded-systems/the-university-of-texas-at-austin-embedded-systems-shape-the-world-microcontroller-input-output">edX</a></li> </ul> </li> </ul>]]></content><author><name></name></author><category term="robotics"/><summary type="html"><![CDATA[Collection of useful resources for learning robotics.]]></summary></entry><entry><title type="html">[CAN 04] - Gripper Motor Control with CAN Bus</title><link href="https://dokkev.github.io/motorcan/" rel="alternate" type="text/html" title="[CAN 04] - Gripper Motor Control with CAN Bus"/><published>2023-12-05T00:00:00+00:00</published><updated>2023-12-05T00:00:00+00:00</updated><id>https://dokkev.github.io/motorcan</id><content type="html" xml:base="https://dokkev.github.io/motorcan/"><![CDATA[<p><strong>Code: [<a href="https://github.com/dokkev/MotorControl-CAN/blob/main/can_motor_control/can_motor_control.ino">GitHub</a>]</strong></p> <p>Previous Posts:</p> <ul> <li><a href="/aboutcan/">What is CAN?</a></li> <li><a href="/socketcan/">Setting up SocketCAN on Linux</a></li> <li><a href="/esp32can/">SocketCAN Communication with ESP32</a></li> </ul> <p><a href="http://www.youtube.com/watch?v=MmSt8G7N8ik"><img src="http://img.youtube.com/vi/MmSt8G7N8ik/0.jpg" alt="Video"/></a></p> <div class="caption"> Optimo Manipulator Pusing and Grabbing a Jenga Block </div> <p>In the previous posts, we have achieved communicating setting up SocketCAN on Ubuntu and communicating with ESP32. In this post, we will control 1-DOF roboric girpper with ESP32 and SocketCAN using <a href="https://simplefoc.com/">SimpleFOC</a> Arduino library.</p> <p>This is a collaborative work <a href="https://roboligent.com/">Roboligent</a> with their robot manipulator, Optimo.</p> <h2 id="hardware">Hardware</h2> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/optimo-480.webp 480w,/assets/img/can/optimo-800.webp 800w,/assets/img/can/optimo-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/optimo.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="optimo" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/gripper-480.webp 480w,/assets/img/can/gripper-800.webp 800w,/assets/img/can/gripper-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/gripper.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="gripper" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Left: Optimo Arm Right: 1-DOF Robotic Gripper </div> <ul> <li><a href="https://docs.simplefoc.com/simplefocmini">SimpleFOC Mini</a></li> <li><a href="https://www.aliexpress.com/i/2251832870920974.html?gatewayAdapt=4itemAdapt">HT2205 with AS5048A Encoder</a> Onlly used for testing not for the gripper</li> <li><a href="https://www.amazon.com/Comimark-Transceiver-TJA1050-Controller-Schnittstelle/dp/B07W4VZ2F2">TJA1050 CAN Transceiver</a></li> <li><a href="https://a.co/d/8sRDkUT">ESP32 Dev Board</a></li> <li><a href="https://makerbase3d.com/product/makerbase-canable-v2/?srsltid=AfmBOoo8SgfMBKoPkINomkXkyG8g6XlvwngQso5DAq0qLKPFEoTqkcba">Makerbase CANable 2.0 USB to CAN adapter</a></li> </ul> <h2 id="wiring">Wiring</h2> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/motor_wire-480.webp 480w,/assets/img/can/motor_wire-800.webp 800w,/assets/img/can/motor_wire-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/motor_wire.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="motor-wiring" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Wiring Diagram for Motor Control </div> <ul> <li> <p>The wiring for ESP32 and CAN Transceiver is same as the <a href="/esp32can/">previous post</a>. Some TJA1050 CAN Transceiver modules and USB-CAN deviuces include internal 120 ohm termination resistor. If you are unsure, measure the resistance between CAN-H and CAN-L wires to ensure it’s reading 60 ohm.</p> </li> <li> <p>Connect the BLDC motor’s u, v, w phases to the SimpleFOC Mini boards’ M1, M2, and M3 pins. The phase order does matter. If they are in a wrong order, the motor will not commmutate properly or run in the opposite direction. SimpleFOC Mini board will need a separate power supply. I will be providing 12 V to control HT2205 motor.</p> </li> <li> <p>Connect IN1, IN2, IN3, and EN pins to ESP32 GPIO pins while GND connects to the ground of ESP32.</p> </li> <li> <p>Supply 5V to SPI encoder and connect the SPI pins to ESP32. Most ESP32 have pre-assigned default SPI pins, but these pin assignment can be different depending on the board. You can check the default SPI pinout of your ESP32 board from the following code:</p> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void setup() {
  
  Serial.begin(115200);
  Serial.print("MOSI: ");
  Serial.println(MOSI);
  Serial.print("MISO: ");
  Serial.println(MISO);
  Serial.print("SCK: ");
  Serial.println(SCK);
  Serial.print("SS: ");
  Serial.println(SS);  
}

void loop() {
}
</code></pre></div></div> <ul> <li> <p>Make sure that there is a proper airgap between the motor magnet and the encoder if you are using magnetic encoder. The recommended airgap is usually specified in the encoder datasheet. The typical airgap for AS5048a is 1 mm airgap, but it depends on how the strength of the magnet. Improper airgap can cause noise in the signal and faulty readings.</p> </li> <li> <p>If you are trying to configue multiple SPI encoders with a shared bus (same MOSI, MISO, SCLK) but differnt chip select pins (CS), the physical wire lengths significantly affect the signal integrity. The longer the wire, the more the signal degrades. From my exerience, 3 SPI devices on the same bus with 80 MHz CLK had a maximum of 10 cm wire length. If you are using a longer wire, you may need to reduce the SPI CLK frequency. If you are 2 SPI devices, I recommend separating the SPI bus since ESP32 provides 2 SPI interfaces. You can more information <a href="https://randomnerdtutorials.com/esp32-spi-communication-arduino/">here</a>.</p> </li> <li> <h2 id="flashing-the-arduino-code">Flashing the Arduino Code</h2> </li> </ul> <p>Make sure to install <a href="https://docs.simplefoc.com/installation">SimpleFOC</a> and <a href="https://github.com/sandeepmistry/arduino-CAN">Arduio-CAN</a> libraries for Arduino IDE.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/diagram-480.webp 480w,/assets/img/can/diagram-800.webp 800w,/assets/img/can/diagram-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/diagram.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="comm-diagram" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Communication Diagram for Motor Control </div> <p>The host computer will send the desired torque command in <code class="language-plaintext highlighter-rouge">double</code> format to the ESP32 via CAN bus. The ESP32 will receive the torque command and send the current motor position in <code class="language-plaintext highlighter-rouge">double</code> back to the host computer.</p> <p>Since the CAN data can hold up to 8 bytes, we can directly encode the <code class="language-plaintext highlighter-rouge">double</code> data of torque command or motor position into the CAN data buffer with LSB order. Function such as <code class="language-plaintext highlighter-rouge">std::memcpy</code> for C++ or <code class="language-plaintext highlighter-rouge">memcpy</code> in Arduino will take care of packing the <code class="language-plaintext highlighter-rouge">double</code> data into the 1 x 8 byte buffer. However, make sure to check the endianness of the data to make sure the data is packed in LSB order.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void packDouble(double data, uint8_t *dataBuffer) {
    memcpy(dataBuffer, &amp;data, sizeof(double));
}
</code></pre></div></div> <p>Otherwise, we can directly allocate each byte of the <code class="language-plaintext highlighter-rouge">double</code> data into the CAN data buffer like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void packDouble(double data, uint8_t *dataBuffer) {
    uint64_t dataAsInt = *reinterpret_cast&lt;uint64_t*&gt;(&amp;data); // Reinterpret the double as a uint64_t
    dataBuffer[0] = (uint8_t)dataAsInt;
    dataBuffer[1] = (uint8_t)(dataAsInt &gt;&gt; 8);
    dataBuffer[2] = (uint8_t)(dataAsInt &gt;&gt; 16);
    dataBuffer[3] = (uint8_t)(dataAsInt &gt;&gt; 24);
    dataBuffer[4] = (uint8_t)(dataAsInt &gt;&gt; 32);
    dataBuffer[5] = (uint8_t)(dataAsInt &gt;&gt; 40);
    dataBuffer[6] = (uint8_t)(dataAsInt &gt;&gt; 48);
    dataBuffer[7] = (uint8_t)(dataAsInt &gt;&gt; 56);
}
</code></pre></div></div> <p>which is not clean but safe way to pack the data.</p> <p>When a command is recived from the host computer, the ESP32 will send command current to motor by converting the torque command to current command with pre-defiend torque constant and respond with the motor position to the host computer.</p> <p>We can implement a simple <a href="https://blog.mbedded.ninja/programming/operating-systems/linux/how-to-use-socketcan-with-c-in-linux/">C++ code to read and write over SocketCAN</a> to control the motor.</p> <p><a href="http://www.youtube.com/watch?v=8PiBqahbf7M"><img src="http://img.youtube.com/vi/8PiBqahbf7M/0.jpg" alt="Video"/></a></p> <div class="caption"> Motor Cotnrol with SocketCAN. In the video, I only sent float data in ESP32 and received the same float data back from ESP32 instead of double. In this case, the CAN data buffer is 4 bytes instead of 8 bytes. </div> <p>Now we can control the gripper motor using the same setup.</p> <p>Using the linear motion of the belt, we can achieve parallel gripper motion. The belt is connected to the motor shaft and the gripper jaws. When the motor rotates, the belt moves the jaws in the opposite direction.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/gripper_mech-480.webp 480w,/assets/img/can/gripper_mech-800.webp 800w,/assets/img/can/gripper_mech-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/gripper_mech.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="gripper_mech" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Mechanism for the Parallel Gripper with one motor </div> <p>We recorded the joint trajectories including the gripper motor to push the jenga piece and grab it by kinestheic teaching (manually driving the robot). We can use the recorded joint trajectories to replay the same motion.</p> <p><a href="http://www.youtube.com/watch?v=MmSt8G7N8ik"><img src="http://img.youtube.com/vi/MmSt8G7N8ik/0.jpg" alt="Video"/></a></p> <div class="caption"> Optimo Manipulator Pusing and Grabbing a Jenga Block </div>]]></content><author><name></name></author><category term="Hardware Development"/><category term="Robotic Manipulation"/><summary type="html"><![CDATA[Single Motor Control with ESP32, simpleFOC, and SocketCAN for Robotic Gripper]]></summary></entry><entry><title type="html">[CAN 03] - Communicating to ESP32 with SocketCAN</title><link href="https://dokkev.github.io/esp32can/" rel="alternate" type="text/html" title="[CAN 03] - Communicating to ESP32 with SocketCAN"/><published>2023-09-10T00:00:00+00:00</published><updated>2023-09-10T00:00:00+00:00</updated><id>https://dokkev.github.io/esp32can</id><content type="html" xml:base="https://dokkev.github.io/esp32can/"><![CDATA[<p>Previous Posts:</p> <ul> <li><a href="/aboutcan/">What is CAN?</a></li> <li><a href="/socketcan/">Setting up SocketCAN on Linux</a></li> </ul> <p><strong>Code: [<a href="https://github.com/dokkev/MotorControl-CAN/blob/main/CANSenderReceiver/CANSenderReceiver.ino">GitHub</a>]</strong></p> <h2 id="hardware">Hardware</h2> <p>I will be using USB-CAN adapter to connect my Ubuntu computer to ESP32 with TJA1050 CAN transceiver. Since <a href="https://docs.espressif.com/projects/esp-idf/en/release-v3.3/api-reference/peripherals/can.html">ESP32 already includes CAN controller</a>, we only need CAN transceiver. Note that not every microcontroller comes with CAN controller, so you may need to use external CAN controller like MCP2515.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/esp32-480.webp 480w,/assets/img/can/esp32-800.webp 800w,/assets/img/can/esp32-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/esp32.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="esp32" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/tja-480.webp 480w,/assets/img/can/tja-800.webp 800w,/assets/img/can/tja-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/tja.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="tja1050" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/usb-can-480.webp 480w,/assets/img/can/usb-can-800.webp 800w,/assets/img/can/usb-can-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/usb-can.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="usb-can" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Left: ESP32 Middle: TJA1050 Right: USB-CAN Adapter </div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/wiring-480.webp 480w,/assets/img/can/wiring-800.webp 800w,/assets/img/can/wiring-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/wiring.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="wiring" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Wiring ESP32 to TJA1050 and USB-CAN Adapter </div> <h2 id="setting-up-your-esp32-with-can-transceiver">Setting up your ESP32 with CAN Transceiver</h2> <p>Supply 5V to the TJA1050 and connect the CANH and CANL to corresponding GPIO pins on ESP32. Any GPIO pins can be used as long as they have read and write capabilities. The default GPIO pins for CAN TX and RX on ESP32 are GPIO 16 (RX) and GPIO 17 (TX).</p> <p>I will be using Arduino IDE to program ESP32 with <a href="https://github.com/sandeepmistry/arduino-CAN">Arduino CAN library</a> which provides good high-level API for CAN communication.</p> <p>You can add ESP32 boards to Arduino IDE by following the instructions <a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">here</a>.</p> <blockquote> <p>IMPORTANT! Note that there is a <a href="https://github.com/sandeepmistry/arduino-CAN/issues/62">glitch that ESP32 cuts the baudrate in half</a>. If you want to set the baudrate to 500 kbps, you need to set it to 1000 kbps (1 Mbps) in the code like this: <code class="language-plaintext highlighter-rouge">CAN.begin(1000E3);</code></p> </blockquote> <p>If you want to resolve it add the following line to <code class="language-plaintext highlighter-rouge">ESP32SJA1000.cpp</code> in <code class="language-plaintext highlighter-rouge">CAN/src</code> in Arduino library at line <code class="language-plaintext highlighter-rouge">126</code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>modifyRegister(REG_BTR1, 0x80, 0x80); // SAM = 1
writeRegister(REG_IER, 0xff); // enable all interrupts
modifyRegister(REG_IER, 0x10, 0); //brp_div will prescale BRP by 2. Only available on ESP32
Revision 2 or later. Reserved otherwise 
</code></pre></div></div> <p>Flash the code above to ESP32. If you get error message: <code class="language-plaintext highlighter-rouge">A fatal error occurred: Could not open /dev/ttyUSB0, the port doesn't exist Failed uploading: uploading error: exit status 2</code>, run the following command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo adduser &lt;username&gt; dialout
sudo chmod a+rw /dev/ttyUSB0
</code></pre></div></div> <p>Change <code class="language-plaintext highlighter-rouge">&lt;username&gt;</code> to your username and <code class="language-plaintext highlighter-rouge">/dev/ttyUSB0</code> to your USB port.</p> <p>This code reads CAN messages and print them to the serial monitor. It also sends a CAN message with the data <code class="language-plaintext highlighter-rouge">hello</code> and RTR request every second.</p> <p>If the CAN transceiver is connected correctly, ESP32 will fail to send the CAN message and get stuck in <code class="language-plaintext highlighter-rouge">CAN.endPacket()</code> function.</p> <h2 id="reading-can-from-terminal">Reading CAN from Terminal</h2> <p>Set the CAN state to <code class="language-plaintext highlighter-rouge">UP</code> with a desired bitrate. Assuming you are using <code class="language-plaintext highlighter-rouge">candlelight</code> firmware, you can set the bitrate to 500 kbps by running:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ip link set up can0 type can bitrate 500000
</code></pre></div></div> <p>Open a new terminal and run:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>candump can0
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/read_hello-480.webp 480w,/assets/img/can/read_hello-800.webp 800w,/assets/img/can/read_hello-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/read_hello.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="read_hello" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Received CAN messages from ESP32 by `candump can0` </div> <p>The CAN message data is in the hexadecimal format. You can convert it using <a href="https://www.rapidtables.com/convert/number/hex-to-ascii.html">ASCII table</a></p> <p><code class="language-plaintext highlighter-rouge">68 65 6C 6C 6F =&gt; hello</code></p> <h2 id="writing-can-from-terminal">Writing CAN from Terminal</h2> <p>Now let’s send CAN messages to ESP32. Using th ASCII table, we can find the hexadecimal value of <code class="language-plaintext highlighter-rouge">hello</code> is <code class="language-plaintext highlighter-rouge">68 65 6C 6C 6F</code>. On the terminal, we can send the CAN message with desired ID and data with the following format: <code class="language-plaintext highlighter-rouge">cansend [options] &lt;interface&gt; &lt;CAN ID&gt;#&lt;data&gt;</code></p> <p>Run the following command on a terminal to send the “hello” CAN message with CAN ID 0x123 to ESP32:</p> <p>If you didn’t connect your CAN transceiver + ESP32 to the USB-CAN adapter correctly, the TX buffer will be full and the CAN message will not be sent.</p> <p>Upon sucessful connection, you will see the CAN messages received in the serial monitor of Arduino IDE.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cansend can0 123#68656C6C6F
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/hello_esp-480.webp 480w,/assets/img/can/hello_esp-800.webp 800w,/assets/img/can/hello_esp-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/hello_esp.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="hello_esp" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Received CAN messages displayed in the serial monitor of Arduino IDE </div> <p>Now let’s try to send random CAN messages to ESP32</p> <p>Run the following command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cangen can0
</code></pre></div></div> <p>This command will start generating random CAN messages continuously.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/cangen_esp-480.webp 480w,/assets/img/can/cangen_esp-800.webp 800w,/assets/img/can/cangen_esp-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/cangen_esp.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="cangen_esp" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Received CAN messages displayed in the serial monitor of Arduino IDE </div> <p>Messages are not encoded correctly because canReceiver() function converts the data to char using ASCII. You can modify the function to print the data in hexadecimal format. Instead of <code class="language-plaintext highlighter-rouge">Serial.print ((char) CAN.read());</code>, you can use <code class="language-plaintext highlighter-rouge">Serial.print (CAN.read(), HEX);</code> to print the data in hexadecimal format.</p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[SocketCAN Communication with ESP32]]></summary></entry><entry><title type="html">[CAN 02] - Setting up SocketCAN on Linux</title><link href="https://dokkev.github.io/socketcan/" rel="alternate" type="text/html" title="[CAN 02] - Setting up SocketCAN on Linux"/><published>2023-09-02T00:00:00+00:00</published><updated>2023-09-02T00:00:00+00:00</updated><id>https://dokkev.github.io/socketcan</id><content type="html" xml:base="https://dokkev.github.io/socketcan/"><![CDATA[<p>Previous Post:</p> <ul> <li><a href="/aboutcan/">What is CAN?</a></li> </ul> <p>In the previous post, we discussed the basics of CAN bus and its applications in robotics. In this post, we will learn how to set up SocketCAN on Ubuntu computers to set up CAN communication.</p> <h2 id="hardware">Hardware</h2> <p>I have tested the following USB-CAN adapters with SocketCAN on Ubuntu 22.04 with 6.8.0-48-generic kerneal and 5.15.129-rt67 real-time kernel.</p> <ul> <li><a href="https://makerbase3d.com/product/makerbase-canable-v2/?srsltid=AfmBOoo8SgfMBKoPkINomkXkyG8g6XlvwngQso5DAq0qLKPFEoTqkcba">Makerbase CANable 2.0 USB to CAN adapter</a></li> <li><a href="https://www.amazon.com/dp/B07P9JGXXB?ref=ppx_yo2ov_dt_b_product_details&amp;th=1">USB CAN Converter Module</a></li> <li><a href="https://a.co/d/6rcsDxE">DSD TECH USB to CAN Adapter</a></li> <li><a href="https://www.peak-system.com/PCAN-USB-FD.365.0.html?&amp;L=1">PCAN-USB FD</a> - make sure to compile the driver with <code class="language-plaintext highlighter-rouge">netdev</code> option. The default is <code class="language-plaintext highlighter-rouge">chardev</code> which is not compatible with SocketCAN.</li> </ul> <h2 id="setting-up-socketcan">Setting up SocketCAN</h2> <p>Install <a href="https://github.com/linux-can/can-utils"><code class="language-plaintext highlighter-rouge">can-utils</code></a> by running:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install can-utils
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">can-utils</code> repository allows user to debug and test the CAN bus via terminal commands.</p> <p>Plug the USB-CAN device into the computer, and you can check the device by running:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lsusb 
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/lsusb-480.webp 480w,/assets/img/can/lsusb-800.webp 800w,/assets/img/can/lsusb-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/lsusb.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="lsusb" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Output of `lsusb` command. You can see that I have two USB-CAN devices connected to my computer. </div> <p>Based on the what frimware in installed in our USB-CAN adapter, we may need to manually load your device. Since SocketCAN is network interface, we can use <code class="language-plaintext highlighter-rouge">ip</code> command to check the status of CAN bus if the firmware is <code class="language-plaintext highlighter-rouge">Candlelight</code> assuming it’s a <a href="https://canable.io/">CANable</a> device. Run the following command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip link ls
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/iplinkls-480.webp 480w,/assets/img/can/iplinkls-800.webp 800w,/assets/img/can/iplinkls-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/iplinkls.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="iplinkls" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Output of `ip link ls` command. You can see that my SockteCAN device `can0` is at `DOWN` state. Since my PCAN-USB FD driver is compiled with `chardev`, you won't see the PCAN device in the network interface. </div> <p>If you see your CAN bus like <code class="language-plaintext highlighter-rouge">can0</code>, follow the Option 1.</p> <p>If you don’t see your can bus like <code class="language-plaintext highlighter-rouge">can0</code>, you have to manually load it by <code class="language-plaintext highlighter-rouge">slcan</code> (CAN over serial line interfaces) by following the Option 2.</p> <h3 id="changing-usb-can-device-firmware">Changing USB-CAN device firmware</h3> <p>If your device is compatible with CANable firmware, you can <a href="https://canable.io/updater/">change the frimware</a> to either <code class="language-plaintext highlighter-rouge">candlelight</code> or <code class="language-plaintext highlighter-rouge">slcan</code>. with <code class="language-plaintext highlighter-rouge">candlelight</code> the usb-can device shows up as a native CAN device with SocketCAN and has higher performance than <code class="language-plaintext highlighter-rouge">slcan</code>. However, <code class="language-plaintext highlighter-rouge">candlelight</code> frimware is not compatible with CAN-FD.</p> <p>Most CANable devices come with <code class="language-plaintext highlighter-rouge">slcan</code> firmware, and `slcan enumerates as a serial device with CAN-FD support.</p> <h3 id="option-1-using-candlelight-to-set-up-can-bus">Option 1: Using <code class="language-plaintext highlighter-rouge">candlelight</code> to set up CAN bus</h3> <p>To set the CAN bus to <code class="language-plaintext highlighter-rouge">UP</code> state with 500 kpbs baudrate, run:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ip link set up can0 type can bitrate 500000
</code></pre></div></div> <p>And you can adjust the baudrate by changing the <code class="language-plaintext highlighter-rouge">bitrate</code> argument.</p> <p>Run <code class="language-plaintext highlighter-rouge">ip link ls</code> to check the status of the CAN bus.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/up-480.webp 480w,/assets/img/can/up-800.webp 800w,/assets/img/can/up-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/up.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="up" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Output of `ip link ls` command. You can see that my SockteCAN device `can0` is at `UP` state. </div> <h3 id="option-2-using-slcan-to-set-up-can-bus">Option 2: Using <code class="language-plaintext highlighter-rouge">slcan</code> to set up CAN bus</h3> <p>check the USB port number of the USB-CAN device by running:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls /dev/ttyACM*
</code></pre></div></div> <p>Then your device may show up as <code class="language-plaintext highlighter-rouge">/dev/ttyACMx</code>. While x is an arbitrary number depending on other USB devices connected to your computer. You can run the following command to load the device (make sure to replace <code class="language-plaintext highlighter-rouge">x</code> with the number you found):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo slcand -o -c -s6 /dev/ttyACMx can0
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">-s6</code> argument determines the baudrate of the CAN bus. The options are:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-s0 = 10k
-s1 = 20k
-s2 = 50k
-s3 = 100k
-s4 = 125k
-s5 = 250k
-s6 = 500k
-s7 = 750k
-s8 = 1M
</code></pre></div></div> <p>Then you can check the status of the CAN bus from <code class="language-plaintext highlighter-rouge">ip link ls</code> command. You should see the <code class="language-plaintext highlighter-rouge">can0</code> device is at <code class="language-plaintext highlighter-rouge">DOWN</code> state.</p> <p>In order to read and write to CAN bus, you have to bring the <code class="language-plaintext highlighter-rouge">can0</code> device <code class="language-plaintext highlighter-rouge">UP</code> state by running:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ifconfig can0 up
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/up-480.webp 480w,/assets/img/can/up-800.webp 800w,/assets/img/can/up-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/up.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="up" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Output of `ip link ls` command. You can see that my SockteCAN device `can0` is at `UP` state. </div> <blockquote> <p>IMPORTANT: If you unplug the USB-CAN device and plug it back in, your USB port number may change (x in <code class="language-plaintext highlighter-rouge">/dev/ttyACMx</code>). To avoid checking the USB port number every time create a symlink in <code class="language-plaintext highlighter-rouge">/dev</code> using <code class="language-plaintext highlighter-rouge">/etc/udev/rules</code>. To do that you need to know your vendor and product ID of the USB-CAN device.</p> </blockquote> <h4 id="setting-up-udev-rules-to-create-symlink-for-slcan">Setting up udev rules to create symlink for <code class="language-plaintext highlighter-rouge">slcan</code></h4> <p>I am testing this with Makerbase CANable 2.0 USB to CAN adapter. Run the following command to get the vendor and product ID of the USB-CAN device:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lsusb
</code></pre></div></div> <p>then you will see the output like:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>==&gt; Bus 001 Device 042: ID 16d0:117e MCS CANable2 b158aa7 GitHub - normaldotcom/canable2-fw
</code></pre></div></div> <p>16d0 is your ATTRS{idVendor}, and 117e is your ATTRS{idProduct}</p> <p>Now create a new rule by this command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nano /etc/udev/rules.d/99-usb-serial.rules
</code></pre></div></div> <p>use 99 ~ 90 to prevent override</p> <p>and add the following to the rules file:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ACTION=="add", SUBSYSTEM=="tty", ATTRS{idVendor}=="16d0", ATTRS{idProduct}=="117e", SYMLINK+="ttycan"
</code></pre></div></div> <p>ctrl + x and y to save and exit. <code class="language-plaintext highlighter-rouge">ttycan</code> can be replaced your desired symlink name (for me, SYMLINK name had to be all lowercase in order to work).</p> <p>reload the udev/rules.d by: <code class="language-plaintext highlighter-rouge">sudo udevadm control --reload-rules</code></p> <p>Unplug and plug back in the USB-CAN module just in case, and run:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls -l /dev/ttycan
</code></pre></div></div> <p>Then it should output:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>==&gt; lrwxrwxrwx 1 root root 7 Sep 12 14:01 /dev/ttycan -&gt; ttyACM5
</code></pre></div></div> <p>You can see that ttycan is linked to ttyACMx Lastly, compare <code class="language-plaintext highlighter-rouge">udevadm info -a /dev/ttyACM5 and udevadm info -a /dev/ttycan</code> to make sure they output the same result.</p> <p>You can now use <code class="language-plaintext highlighter-rouge">/dev/ttycan</code> instead of <code class="language-plaintext highlighter-rouge">/dev/ttyACMx</code> in the <code class="language-plaintext highlighter-rouge">slcand</code> command.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo slcand -o -c -s6 /dev/ttycan can
sudo ip link set up can0 type can
</code></pre></div></div> <p>Netx Post: <a href="/esp32can/">Communicating to ESP32 with SocketCAN</a></p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[Setting up SocketCAN]]></summary></entry><entry><title type="html">[CAN 01] - What is CAN?</title><link href="https://dokkev.github.io/aboutcan/" rel="alternate" type="text/html" title="[CAN 01] - What is CAN?"/><published>2023-09-01T00:00:00+00:00</published><updated>2023-09-01T00:00:00+00:00</updated><id>https://dokkev.github.io/aboutcan</id><content type="html" xml:base="https://dokkev.github.io/aboutcan/"><![CDATA[<h1 id="introduction">Introduction</h1> <h3 id="what-is-control-area-network-can">What is Control Area Network (CAN)?</h3> <p>CAN is a communication interface widely used in the automotive industry due to its safety and reliability. CAN allows multiple electronic devices such as sensors and motor controllers to communicate in real-time via shared bus in which distributed CAN Nodes communicate through without a “master device”. CAN is a robust communication interface which can tramsits data over a long distance from 40 meters to 1,000 meters depending on the baudrate in hard coniditon subject to noise, interference, temerature, vibration, etc.</p> <h3 id="how-is-it-used-in-robotics">How is it used in Robotics?</h3> <p>In robotics, the Controller Area Network (CAN) is widely adopted for real-time communication between a host computer and motor driver modules. For complex robots like multi-DOF manipulators or legged robots, each motor driver module typically includes a microcontroller running control algorithms, such as Field-Oriented Control (FoC), to accurately control BLDC (Brushless DC) motors. In this setup, the microcontroller in each motor module calculates the PWM (Pulse Width Modulation) signals needed to control motor phases and achieve the desired movements. These PWM signals are then sent to motor drivers, such as the DRV8313, which uses them to drive the motor’s three phases. The control loop for each motor typically runs at a high frequency over 1 kHz, and a lot of motor driver modules such as ODrive, Mjbots, etc. include CAN controller and transceiver to enable the communication between the microcontroller and host computer.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/can-480.webp 480w,/assets/img/can/can-800.webp 800w,/assets/img/can/can-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/can.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="can" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> CAN Bus </div> <p>The CAN bus can also support real-time, high-frequency impedance control by closing the control loop through the CAN bus itself, rather than solely relying on the control loop inside the microcontroller in the driver module. Impedance control plays a crucial role for robots that need to adapt their flexibility when interacting with dynamic environments or external forces. This adaptability is especially valuable for legged robots that frequently make and break contact with the environment. Impedance control allows these robots to safely absorb impact upon contact. Legged robots can navigate challenging terrains, avoid obstacles, and maintain balance by constantly adjusting their feed-forward torque and impedance gains.</p> <p>\(\tau = M(q)\ddot{q} + D(\dot{q}_{d} - \dot{q}) + K(q_{d} - q) + g(q)\)</p> <div class="caption"> Joint Impedance Control Loop where M is the mass matrix, D is the damping matrix, K is the stiffness matrix, and g is the gravity vector with the generalized coordinates q. K and D are the impedance gains which determine the behavior of the joint when external forces are applied. </div> <p>For example, MIT mini cheetah robot uses CAN bus to communicate with the motor driver modules to achieve real-time impedance control.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/mini-cheetah-480.webp 480w,/assets/img/can/mini-cheetah-800.webp 800w,/assets/img/can/mini-cheetah-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/mini-cheetah.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="mini-cheetah" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> MIT Mini Cheetah </div> <p>This awesome open-source quadruped robot’s communication structure have been adopted by many other actuators and robot companies.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/ak10-9-480.webp 480w,/assets/img/can/ak10-9-800.webp 800w,/assets/img/can/ak10-9-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/ak10-9.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="ak10-9" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/go1-480.webp 480w,/assets/img/can/go1-800.webp 800w,/assets/img/can/go1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/go1.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="go1" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/h1-480.webp 480w,/assets/img/can/h1-800.webp 800w,/assets/img/can/h1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/can/h1.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="h1" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Robotic Systems with CAN communication Left: CubeMars AK10-9, Middle and Right: Unitree Go1 and H1 </div> <h3 id="limitation-of-can-bus-in-robotics">Limitation of CAN Bus in Robotics</h3> <p>Mini Cheetah has 4 CAN channels while 3 motors are connected to each channel to control total 12 motors. This is one of the limitation of using CAN bus for real-time control robots. The maximum baudrate of CAN bus is 1 Mbps, and the bus can be easily overloaded when the number of motors increases in high control frequency. Assuming the control loop is running at 1 kHz with a tyical non-RTR standard CAN frame with 11 bits of data, the CAN bus is populated with 22,000 bps with command frame and response frame of a single actuator. This is approximately 22.2% of the 1 Mbps CAN bus. Since it’s recommended to keep the CAN bus load less than 70~80%, the maximum number of actuators that can be connected to a single CAN channel is 3. Decreasing the control loop frequencty will reduce the load on the CAN bus, but lower control loop frequency will not only reduce the performance but also increase the instability of the robot.</p>]]></content><author><name></name></author><category term="Hardware Development"/><summary type="html"><![CDATA[What is CAN Bus and how is it used in robotics?]]></summary></entry></feed>